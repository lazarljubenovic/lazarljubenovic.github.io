const t=Symbol("This symbol ensures type safety. If you're seeing this in an error, it means you haven't used ValueProvider, ClassProvider, ProxyProvider or FactoryProvider from @morkite/injectus for creating a Provider.");function e(e,n){return{[t]:!0,type:"value-provider",token:e,value:n}}function n(e){switch(e.type){case"value-provider":return{[t]:!0,type:"factory-provider",token:e.token,factory:()=>e.value};case"class-provider":return{[t]:!0,type:"factory-provider",token:e.token,factory:t=>new e.classConstructor(t)};case"proxy-provider":return{[t]:!0,type:"factory-provider",token:e.token,factory:t=>t.resolve(e.token)};case"factory-provider":return e}}class r{resolved;successful=!0;constructor(t){this.resolved=t}}class i{context;successful=!1;constructor(t){this.context=t}}class s{#t;constructor(t){this.#t=t??"?"}toString(){return`[InjectusToken ${this.#t}]`}}function o(t){return t instanceof s?t.toString():`[ConstructorToken ${t.name}]`}class a extends Error{constructor(t){super();const e=new Array;for(;"request"!=t.type;)"dependency"==t.type&&e.push(t.goal),t=t.master;e.push(t.goal),this.message=`Could not resolve ${e.map(o).join(" <- ")}.`}}class c{#e=null;#n=new Map;#r=new Map;#i=null;constructor(t){this.#e=t??null}provide(...t){for(const e of t){if(this.#n.has(e.token))throw new Error(`Token ${o(e.token)} already provided.`);const t=n(e);this.#n.set(t.token,t)}}resolve(t,{fallback:e=null}={}){this.#i=null!=this.#i?{type:"dependency",master:this.#i,goal:t}:function(t,e){return{type:"request",container:t,goal:e}}(this,t);const n=this.#s(t);if(1==n.successful)return n.resolved;let r=n.context;for(;"request"!=r.type;){if("dependency"==r.type)throw new a(n.context);r=r.master}if(null!=e)return e();throw new a(n.context)}#s(t){if(null==this.#i)throw new Error(`Cannot start resolution without context. Tried resolving ${o(t)}.`);if(this.#r.has(t)){const e=this.#r.get(t);return this.#i=null,new r(e)}const e=this.#n.get(t)??null;if(null!=e){const n=e.factory(this);return this.#r.set(t,n),this.#i=null,new r(n)}if(null!=this.#e){const e=(n=this.#i,s=this.#e,{type:"next-container",master:n,container:s}),r=this.#e;return console.assert(null==r.#i),r.#i=e,this.#i=null,r.#s(t)}var n,s;const a=this.#i;return this.#i=null,new i(a)}}const u=new s("@morkite/component/COMPONENT_TRAIT_TOKENS");class l extends Error{map;key;constructor(t,e){super(),this.map=t,this.key=e}get message(){return`Looking up “${this.key}” yielded no results.`}}class h extends Error{map;key;value;constructor(t,e,n){super(),this.map=t,this.key=e,this.value=n}get message(){return`Conflict while trying to set ${this.key} to “${this.value}”; already set to “${this.map.get(this.key)}”.`}}class d{#t;constructor(t){this.#t=t}toString(){return`Token(${this.#t})`}}class p{#o=new Map;has(t){return this.#o.has(t)}get(t,{onMiss:e="null"}={}){if(!this.has(t))switch(e){case"null":return null;case"throw":throw new l(this,t)}return this.#o.get(t)}getMany(t,{onMiss:e="null"}={}){switch(e){case"null":return t.map((t=>this.#o.has(t)?this.#o.get(t):null));case"throw":{const e=new Array;for(const n of t){if(!this.#o.has(n))throw new l(this,n);e.push(this.#o.get(n))}return e}}}set(t,e,{onConflict:n="overwrite"}={}){if(this.has(t))switch(n){case"overwrite":break;case"ignore":return this;case"throw":throw new h(this,t,e)}return this.#o.set(t,e),this}delete(t,{onMiss:e="ignore"}={}){if(!this.has(t))switch(e){case"ignore":return;case"throw":throw new l(this,t)}this.#o.delete(t)}clear(){this.#o.clear()}}const f=Symbol("@morkite/inspectable/OBSERVABLE");function m(t){return null!=t&&"object"==typeof t&&f in t&&!0===t[f]}class g{#a;#c=new Set;constructor(t){this.#a=t}add(t){const e=this,n={provoke(){t(e.#a)},conclude(){e.#c.delete(n)}};return this.#c.add(n),n}provoke(){for(const t of this.#c)t.provoke()}destroy(){this.#c.clear()}}class w{static Create(t,e){return new w(t,e)}[f]=!0;#u;#l;#h;#d=new Set;#p=new Set;constructor(t,e){this.#u=t,this.#l=e,this.#h=new Array(this.#u.length);for(let t=0;t<this.#u.length;t++){const e=this.#u[t].observe((()=>{this.#d.add(t),this.#f.provoke()}));this.#p.add(e),this.#d.add(t)}}#m=null;get value(){if(this.#d.size>0){for(const t of this.#d)this.#h[t]=this.#u[t].value;this.#d.clear(),this.#m=this.#l(...this.#h)}return this.#m}#f=new g(this);observe(t){return this.#f.add(t)}map(t){return w.Create([this],t)}flatMap(t){return b(w.Create([this],t))}with(...t){return w.Create([this,...t],((...t)=>t))}}const y=Symbol("UNSET");function b(t){const e=new v(y);let n;return t.observe((({value:t})=>{e.set(t.value),n?.conclude(),n=t.observe((({value:t})=>{e.set(t)}))})),w.Create([e],(t=>{if(t==y)throw new Error("Value not yet set.");return t}))}class v{[f]=!0;#m;constructor(t){this.#m=t}get value(){return this.#g(),this.#m}#f=new g(this);observe(t){return this.#g(),this.#f.add(t)}set(t){this.#g(),this.#m=t,this.#f.provoke()}provokeManually(){this.#f.provoke()}#w=!1;#g(){if(this.#w)throw new Error("Cannot operate on a destroyed observable.")}destroy(){this.#f.destroy()}map(t){return w.Create([this],t)}flatMap(t){return b(w.Create([this],t))}with(...t){return w.Create([this,...t],((...t)=>t))}}const T=Symbol("@morkite/core/INPUT");function k(t){return null!=t&&"object"==typeof t&&T in t&&!0===t[T]}class x{[T]=!0;[f]=!0;#y;constructor(t){this.#y=t}#b=!1;#v=!1;#m=null;#T=!1;get didChange(){return this.#T}get value(){if(null!=this.#k)this.#k.needsPull&&(this.#m=this.#k.source.value,this.#k.needsPull=!1);else if(!this.#v&&!this.#b){if(null==this.#y)throw new Error("Value not set.");this.#m=this.#y(),this.#b=!0}return this.#m}#f=new g(this);observe(t){return this.#f.add(t)}set(t){if(this.#g(),null!=this.#k)throw new Error("Cannot set a value manually while an observable is linked.");this.#m=t,this.#T=!0,this.#v=!0}#k=null;link(t){if(this.#g(),null!=this.#k)throw new Error("cannot relink yet");const e=()=>{if(null==this.#k)throw new Error("Expected “this.#activeLink” to be non-nullish.");this.#k.needsPull=!0,this.#T=!0,this.#f.provoke()},n=t.observe(e);this.#k={needsPull:!0,source:t,observance:n},e()}ratify(){this.#T=!1}#w=!1;#g(){if(this.#w)throw new Error("Cannot operate on an input of a destroyed component.")}destroy(){this.#g(),this.#f.destroy(),this.#k?.observance.conclude(),this.#k=null,this.#w=!0}map(t){return w.Create([this],t)}flatMap(t){return b(w.Create([this],t))}with(...t){return w.Create([this,...t],((...t)=>t))}}const C=Symbol("OUTPUT"),D=Symbol("OUTPUT_TYPE");class E{[C]=!0;[D]=void 0;#x=new Set;subscribe(t){const e={onEmit:t,unsubscribe:()=>this.#x.delete(e)};return this.#x.add(e),e}emit(t){for(const e of this.#x)e.onEmit(t)}destroy(){throw new Error("Not implemented.")}}class I{#C;#D;#E=new Array;constructor(t,e){this.#C=t,this.#D=e}get count(){return this.#E.length}at(t){if(!Number.isInteger(t))throw new TypeError(`Index must be an integer, but ${t} was given.`);if(t<0||t>=this.count)throw new RangeError(`Index must be between 0 (inclusive) and ${this.count} (exclusive), but ${t} was given.`);return this.#E[t]}createAt(t,e){if(!this.#C.activated)throw new Error("Cannot spawn a child for an unactivated component. Are you trying to build the tree in the constructor? Use the “onUpdate” hook instead.");if(!Number.isInteger(t))throw new TypeError(`Index must be an integer, but ${t} was given.`);if(t<0||t>this.count)throw new RangeError(`Index must be between 0 (inclusive) and ${this.count} (inclusive), but ${t} was given.`);const n=new c(this.#C.injector),r=this.#D.instantiateOrThrow(e,n);return r.acceptParent(this.#C),r.activate({depth:this.#C.depth+1}),this.#E.splice(t,0,r),r}destroyAt(t){const e=this.ejectAt(t);this.destroyEjected(e)}ejectAt(t){if(!Number.isInteger(t))throw new TypeError(`Index must be an integer, but ${t} was given.`);if(t<0||t>=this.count)throw new RangeError(`Index must be between 0 (inclusive) and ${this.count} (exclusive), but ${t} was given.`);const[e]=this.#E.splice(t,1);return e}reinsertAt(t,e){if(this.#E.includes(e))throw new Error("not ejected or already re-inserted");if(e.parent!=this.#C)throw new Error("not ejected from here");if(!Number.isInteger(t))throw new TypeError(`Index must be an integer, but ${t} was given.`);if(t<0||t>this.#E.length)throw new RangeError(`Index must be between 0 (inclusive) and ${this.count} (inclusive), but ${t} was given.`);this.#E.splice(t,0,e)}destroyEjected(t){if(this.#E.includes(t))throw new Error("not ejected or already re-inserted");if(t.parent!=this.#C)throw new Error("not ejected from here");t.destroy()}createAccessor(){const t=this.#E;return{get count(){return t.length},*iterate(){for(let e=t.length-1;e>=0;e--)yield t[e].traits}}}}class A{#I=new S;markAsDirty(t){this.#I.add(t)}markAsPristine(t){this.#I.remove(t)}iterate(){return this.#I.createIterator()}}class S{#A=0;#S=new Array;createIterator(){return{next:()=>{for(const t of this.#S)if(t.size>0){const[e]=t;return{value:e,done:!1}}return{value:null,done:!0}},[Symbol.iterator](){return this}}}add(t){for(let e=this.#S.length;e<=t.depth;e++){const t=new Set;this.#S.push(t)}const e=this.#S[t.depth];e.has(t)||(e.add(t),this.#A++)}remove(t){if(t.depth>=this.#S.length)return;const e=this.#S[t.depth];e.has(t)&&(e.delete(t),this.#A--)}clear(){for(const t of this.#S)t.clear();this.#A=0}has(t){return this.#S[t.depth].has(t)}get count(){return this.#A}get isEmpty(){return 0==this.#A}get isNotEmpty(){return this.#A>0}}class F{instantiateOrThrow(t,e){const n=this.instantiate(t,e);if(null==n)throw new Error("Could not instantiate this component. Make sure you've provided an appropriate component instantiator which can handle this type of component definitions.");return n}}const N=Symbol("@morkite/core/CLASS_CONSTRUCTOR_COMPONENT_INSTANTIATOR");class B extends F{instantiate(t,e){return N in t?new t(e):null}}class M extends F{#F;constructor(t){super(),this.#F=Array.from(t)}instantiate(t,e){for(const n of this.#F){const r=n.instantiate(t,e);if(null!=r)return r}return null}}let V=1001;class R{static[N]=!0;id=V++;injector;traits;#N;#p=new Set;#B=null;#M;get depth(){if(!this.#V)throw new Error("Cannot access depth before activating.");if(null==this.#B)throw new Error("Expected “this.#depth” to be non-nullish.");return this.#B}#R(t){if(null!==this.#B)throw new Error("Expected “this.#depth” to be null.");this.#B=t}constructor(t){this.injector=t,this.#M=this.Inject(u),this.traits=new p,this.#N=t.resolve(A);const e=this.injector.resolve(F);this.childrenManager=new I(this,e),this.traits.set(this.#M.childrenAccessor,this.childrenManager.createAccessor()),this.traits.set(this.#M.debuggingName,this.constructor.name)}#O=new Set;#P=new Set;Input(t=null){const e=new x(t);this.#O.add(e);const n=e.observe((()=>this.markAsDirty()));return this.#p.add(n),e}Output(){const t=new E;return this.#P.add(t),t}emit(t,e=null){if(this.destroyed)throw new Error("An attempt was made to emit an output of a destroyed component.");if(!this.#P.has(t))throw new Error("An attempt was made to emit a foreign output.");t.emit(e)}Inject(t,e){return this.injector.resolve(t,e)}markAsDirty(){this.#N.markAsDirty(this)}#V=!1;#w=!1;get activated(){return this.#V}get destroyed(){return this.#w}activate(t){if(this.#V)throw new Error("Already activated.");this.#R(t.depth),this.#V=!0}update(){if(!this.#V)throw new Error("Cannot update before activation.");if(this.#w)throw new Error("Cannot update after it's been destroyed.");this.onUpdate();for(const t of this.#O)t.ratify();this.#N.markAsPristine(this)}destroy(){if(!this.#V)throw new Error("Cannot destroy before activation.");if(this.#w)throw new Error("Already destroyed.");this.#L=null;for(const t of this.#O)t.destroy();for(const t of this.#p)t.conclude();this.#p.clear(),this.#w=!0}childrenManager;#L=null;get parent(){if(null==this.#L)throw new Error("Expected “this.#parent” to be non-nullish.");return this.#L}acceptParent(t){if(null!=this.#L)throw new Error("The parent cannot be changed.");this.#L=t}}class O extends v{static Create(t){return new O(t)}constructor(t){super(t)}destroy(){super.destroy()}}class P{static Transparent=new P(0,0,0,0);static White=new P(1,1,1);static Black=new P(0,0,0);static Red=new P(1,0,0);static Green=new P(0,1,0);static Blue=new P(0,0,1);static Yellow=new P(1,1,0);static Magenta=new P(1,0,1);static Cyan=new P(0,1,1);static LightGray=new P(.25,.25,.25);static Gray=new P(.5,.5,.5);static DarkGray=new P(.75,.75,.75);#U;uint32_rgba;constructor(t=0,e=0,n=0,r=1){const i=U(t),s=U(e),o=U(n),a=U(r);this.#U=[i,s,o,a];const c=L(i),u=L(s),l=L(o),h=L(a);this.uint32_rgba=h|l<<8|u<<16|c<<24}static Multiply(t,e){const n=t.#U[0]*e.#U[0],r=t.#U[1]*e.#U[1],i=t.#U[2]*e.#U[2],s=t.#U[3]*e.#U[3];return new P(n,r,i,s)}}function L(t){return 255*t|0}function U(t){return t<0?0:t>1?1:t}class _{#_=new Array;get size(){return this.#_.length}peekAtFront(){return this.#_.at(0)}peekAtBack(){return this.#_.at(-1)}popFromFront(){return this.#_.shift()}popFromBack(){return this.#_.pop()}pushToFront(t){this.#_.unshift(t)}pushToBack(t){this.#_.push(t)}}class ${mustBreak;constructor(t){this.mustBreak=t}}class W extends ${static Instance=new W;constructor(){super(!1)}execute(){}}class j extends ${static Instance=new j;constructor(){super(!0)}execute(){}}class z extends ${#$;constructor(t,e){super(t),this.#$=e}execute(){for(const t of this.#$)t.execute()}}class K{renderer;processorStorage;frame;frameStorage;scheduleProcessing;constructor(t,e,n,r){this.renderer=t,this.processorStorage=e,this.frame=n,this.frameStorage=new p,this.scheduleProcessing=r}repurposeFor(t){this.frame=t,this.frameStorage.clear()}}class G{#W;#j;#z;#K=new _;#G;constructor(t,e){this.#W=t,this.#j=e,this.#z=new p,this.#j.onProcessorCreated(this.#W,this.#z),this.#G=new K(this.#W,this.#z,Symbol(),(t=>{this.#K.pushToFront(t)}))}renderFrame(t){const e=Symbol();this.#G.repurposeFor(e),this.#j.onFrameStart(this.#G),this.#H(t);let n=1e4;for(;this.#K.size>0;){const t=this.#K.popFromFront();if(this.#H(t),n--,n<0)throw new Error("Went insane!")}this.#W.flush(),this.#j.onFrameFinish(this.#G)}#H(t){let e=this.#j.process(t,this.#G);if(e.mustBreak&&(e.execute(),this.#W.flush(),e=this.#j.process(t,this.#G),e.mustBreak))throw new Error("A stubborn nugget indeed!");e.execute()}}const H=class{#q;constructor(t){this.#q=Array.from(t)}onProcessorCreated(t,e){for(const n of this.#q)n.onProcessorCreated(t,e)}onFrameStart(t){for(const e of this.#q)e.onFrameStart(t)}process(t,e){const n=[];let r=!1;for(const i of this.#q){const s=i.process(t,e);if(s.mustBreak){r=!0;break}n.push(s)}return r?this.createBreakCommand(t,e):new z(!1,n)}createBreakCommand(t,e){const n=this.#q.map((n=>n.createBreakCommand(t,e)));return new z(!0,n)}onFrameFinish(t){for(const e of this.#q)e.onFrameFinish(t)}};class q{#M;constructor(t){this.#M=t}onProcessorCreated(){}onFrameStart(){}process(t){return t.get(this.#M.debuggingName),W.Instance}createBreakCommand(){return j.Instance}onFrameFinish(){}}class Y{#Y=0;get nodesCount(){return this.#Y}reset(){this.#Y=0}extractStats(t){this.#Y++}prettyPrint(){return`Nodes count: ${this.nodesCount}`}}class X{#X=new Y;onProcessorCreated(){}process(t,e){return this.#X.extractStats(e),W.Instance}createBreakCommand(){return j.Instance}onFrameStart(){this.#X.reset()}onFrameFinish(){}}class Q{}class Z extends Q{#Q;constructor(t=Date.now()){super(),this.#Q=t}get tNow(){return Date.now()-this.#Q}}class J{}class tt{tStart;unsubscribe;#Z;#J={tGlobal:0,tLocal:0,elapsed:0};#tt=0;constructor(t,e,n){this.tStart=t,this.unsubscribe=n,this.#Z=e}invoke(t){this.#J.tGlobal=t,this.#J.tLocal=t-this.tStart,this.#J.elapsed=t-this.#tt,this.#Z(this.#J),this.#tt=t}}class et extends J{constructor(t){super(),this.#et=t}#et;#nt=new Set;#rt=null;get tGlobal(){return this.#et.tNow}subscribe(t){const e=this.#nt.size,n=new tt(this.#et.tNow,t,(()=>this.#it(n)));return this.#nt.add(n),0==e&&(this.#rt=requestAnimationFrame(this.#st)),n}#it(t){0!=this.#nt.size&&(this.#nt.delete(t),0==this.#nt.size&&(cancelAnimationFrame(this.#rt),this.#rt=null))}#st=()=>{const t=this.#et.tNow;for(const e of this.#nt)e.invoke(t);this.#rt=requestAnimationFrame(this.#st)};destroy(){this.#nt.clear(),null!=this.#rt&&(cancelAnimationFrame(this.#rt),this.#rt=null)}}class nt{#M;#ot;constructor(t,e){this.#M=t,this.#ot=null==e?.undoEligibilityTraits?null:new Set(e.undoEligibilityTraits)}onProcessorCreated(){}onFrameStart(){}process(t,{scheduleProcessing:e}){if(null==t.get(this.#M.undo)){let n=!1;if(null==this.#ot)n=!0;else for(const e of this.#ot)if(t.has(e)){n=!0;break}if(n){const n=(new p).set(this.#M.undo,t);if(null!=this.#M.debuggingName){const e=t.get(this.#M.debuggingName)??"?";n.set(this.#M.debuggingName,`Undo for "${e}"`)}e(n)}}const n=t.get(this.#M.childrenAccessor);if(null!=n)for(const t of n.iterate())e(t);return W.Instance}createBreakCommand(){return j.Instance}onFrameFinish(){}}class rt extends R{#at=!1;#ct=new Array;onUpdate(){this.#at?this.#ut():(this.#lt(),this.#at=!0)}#ht=null;#lt(){const t=(e=this.template,Array.isArray(e)?e:[e]);var e;this.#ht=t;for(const e of t){const t=this.childrenManager.createAt(this.childrenManager.count,e.componentDefinition);for(const[n,r]of e.bindings){const e=t[n];if(!k(e))throw new Error("unsupported dock type");m(r)?e.link(r):e.set(r)}if(null!=e.children){if(!("children"in t)||!k(t.children))throw new Error("this component does not support children");{class n extends rt{template=e.children}t.children.set(n)}}t.update()}}#ut(){}onDestroy(){this.#ct.splice(0,this.#ct.length)}}const it=Symbol("@morkite/template/INLINE_TEMPLATE_BASED_COMPONENT_DEFINITION");class st extends F{instantiate(t,e){if(null==(n=t)||"object"!=typeof n||!(it in n)||!0!==n[it])return null;var n;const r=t.api,i=t.templateFactory,s=new class extends rt{constructor(t){super(t),Object.entries(r).forEach((([t,e])=>{if(function(t){return null!=t&&"object"==typeof t&&(ot in t||at in t)}(e))Object.defineProperty(this,t,{value:this.Input(e.defaultValueFactory),enumerable:!0,configurable:!0,writable:!0});else{if(!function(t){return null!=t&&"object"==typeof t&&ut in t}(e))throw console.error(e),new Error("Expected an input.");Object.defineProperty(this,t,{value:this.Output(),enumerable:!0,configurable:!0,writable:!0})}})),this.template=i(this)}template}(e);return s}}const ot=Symbol(),at=Symbol();function ct(t=null){return null==t?{[ot]:void 0,defaultValueFactory:null}:{[at]:void 0,defaultValueFactory:t}}const ut=Symbol();function lt(t,e){return{[it]:!0,api:t,templateFactory:e}}function ht(t){return new dt(t)}class dt{componentDefinition;#dt=new Map;#E=null;get bindings(){return this.#dt}get children(){return this.#E}constructor(t){this.componentDefinition=t}bind(t,e){return this.#dt.set(t,e),this}setChildren(t){return this.#E=t,this}}class pt extends R{condition=this.Input();children=this.Input();onUpdate(){if(this.condition.didChange)if(1==this.condition.value&&0==this.childrenManager.count){this.childrenManager.createAt(0,this.children.value).update()}else 0==this.condition.value&&1==this.childrenManager.count&&this.childrenManager.count>0&&this.childrenManager.destroyAt(0)}onDestroy(){}}function ft(t){return t}class mt extends R{items=this.Input();tracker=this.Input((()=>ft));itemComponent=this.Input();#pt=[];#ft;constructor(t){super(t);const e=this.childrenManager,n=this.itemComponent;this.#ft={at:t=>e.at(t),createAt(t,r){const i=n.value,s=e.createAt(t,i);return s.item.set(r),s.index.set(t),s.update(),s},destroyAt(t){e.destroyAt(t)},ejectAt:t=>e.ejectAt(t),reinsertAt(t,n){e.reinsertAt(t,n)},destroyEjected(t){e.destroyEjected(t)}}}onUpdate(){if(this.items.didChange){const t=Array.from(this.items.value);!function(t,e,n,r){const i=new Map;let s=0,o=0,a=1e4;for(;;){if(a--,0==a)throw new Error("almost went insane");if(s>=t.length)break;if(o>=e.length)break;const c=n(t[s]),u=n(e[o]);if(c===u){s++,o++;continue}const l=i.get(u);if(null!=l){r.reinsertAt(o,l),i.delete(u),o++;continue}const h=r.ejectAt(o);i.set(c,h),s++}if(s>=t.length)for(;o<e.length;o++){const t=e[o],s=n(t),a=i.get(s);null!=a?(r.reinsertAt(o,a),i.delete(s)):r.createAt(o,t)}if(o>=e.length){for(;s<t.length;s++)r.destroyAt(o);for(const t of i.values())r.destroyEjected(t);i.clear()}}(this.#pt,t,this.tracker.value,this.#ft),this.#pt=t}}onDestroy(){}}class gt extends R{#at=!1;children=this.Input();providers=this.Input();silenceWarnings=this.Input((()=>!1));onUpdate(){this.#at?gt.#mt||this.silenceWarnings.value||!this.providers.didChange||(console.warn("Changing the providers passed to the <Provide providers={ ... }/> component won't do anything. This warning is logged only the first time it occurs in the entire app. Use the “silenceWarnings” input to silence this warning on a particular component."),gt.#mt=!0):(this.#lt(),this.#at=!0)}onDestroy(){}#lt(){this.injector.provide(...this.providers.value);this.childrenManager.createAt(0,this.children.value).update()}static#mt=!1}const wt=new s("@morkite/webgl-components/3d/TRI_TRAIT_TOKENS");function yt(t=0,e=0){return[t,e]}function bt(t){return t[0]}function vt(t){return t[1]}function Tt(t,e,n){return t[0]=e,t[1]=n,t}function kt(t,e){return t[0]*e[0]+t[1]*e[1]}function xt(t){return Math.hypot(t[0],t[1])}function Ct(t,e,n){const r=Math.cos(n),i=Math.sin(n),s=e[0]*r-e[1]*i,o=e[0]*i+e[1]*r;return t[0]=s,t[1]=o,t}function Dt(t,e,n){return function(t,e,n){return t[0]=e*n[0],t[1]=e*n[1],t}(t,kt(e,n)/kt(n,n),n)}function Et(t,e=1e-6){const n=Math.round(t);return Math.abs(n-t)<e?n:t}function It(t,e,n=1e-6){return Math.abs(t-e)<n}const At=Vt(1,0,0),St=Vt(-1,0,0),Ft=Vt(0,1,0),Nt=Vt(0,-1,0),Bt=Vt(0,0,1),Mt=Vt(0,0,-1);function Vt(t=0,e=0,n=0){return[t,e,n]}function Rt(t){return t[0]}function Ot(t){return t[1]}function Pt(t){return t[2]}function Lt(t){return Vt(Rt(t),Ot(t),Pt(t))}function Ut(t,e){return t[0]=e,t}function _t(t,e){return t[1]=e,t}function $t(t,e){return t[2]=e,t}function Wt(t,e,n,r){return Ut(t,e),_t(t,n),$t(t,r),t}function jt(t,e){return Wt(t,Rt(e),Ot(e),Pt(e))}function zt(t,e){return Wt(t,-Rt(e),-Ot(e),-Pt(e))}function Kt(t,e,n){return Wt(t,Rt(e)+Rt(n),Ot(e)+Ot(n),Pt(e)+Pt(n))}function Gt(t,e,n){return Wt(t,Rt(e)-Rt(n),Ot(e)-Ot(n),Pt(e)-Pt(n))}function Ht(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]}function qt(t,e,n){const[r,i,s]=e,[o,a,c]=n;return Wt(t,i*c-s*a,s*o-r*c,r*a-i*o)}function Yt(t,e,n){return Wt(t,e*Rt(n),e*Ot(n),e*Pt(n))}function Xt(t,e){const n=1/function(t){const[e,n,r]=t;return Math.hypot(e,n,r)}(e);return Yt(t,n,e)}function Qt(t,e,n){return It(Rt(t),Rt(e),n)&&It(Ot(t),Ot(e),n)&&It(Pt(t),Pt(e),n)}function Zt(t=1,e=0,n=0,r=0,i=1,s=0,o=0,a=0,c=1){return[t,e,n,r,i,s,o,a,c]}const Jt=Zt();function te(t,e){return Ut(t,function(t){return t[3]}(e)),_t(t,function(t){return t[4]}(e)),$t(t,function(t){return t[5]}(e)),t}function ee(t){return t[0]}function ne(t){return t[1]}function re(t){return t[0]}function ie(t){return t[1]}function se(t){return t[2]}function oe(t){return t[3]}function ae(t=0,e=0,n=0,r=0){return[t,e,n,r]}function ce(t=1,e=0,n=0,r=0,i=1,s=0,o=0,a=0,c=1,u=0,l=0,h=0){return[t,e,n,r,i,s,o,a,c,u,l,h]}const ue=ce();function le(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t}function he(t,e,n){const[r,i,s,o,a,c,u,l,h,d,p,f]=e,[m,g,w,y,b,v,T,k,x,C,D,E]=n;return t[0]=r*m+o*g+u*w,t[1]=i*m+a*g+l*w,t[2]=s*m+c*g+h*w,t[3]=r*y+o*b+u*v,t[4]=i*y+a*b+l*v,t[5]=s*y+c*b+h*v,t[6]=r*T+o*k+u*x,t[7]=i*T+a*k+l*x,t[8]=s*T+c*k+h*x,t[9]=r*C+o*D+u*E+d,t[10]=i*C+a*D+l*E+p,t[11]=s*C+c*D+h*E+f,t}function de(t=0,e=0,n=0,r=0,i=0,s=0,o=0,a=0,c=0){return[t,e,n,r,i,s,o,a,c]}function pe(t,e){const[n,r,i,s,o,a,c,u,l]=e,h=function(t){const[e,n,r,i,s,o,a,c,u]=t;return e*s*u+i*c*r+a*n*o-e*c*o-i*n*u-a*s*r}(e);return t[0]=(o*l-u*a)/h,t[1]=-(r*l-u*i)/h,t[2]=(r*a-o*i)/h,t[3]=-(s*l-c*a)/h,t[4]=(n*l-c*i)/h,t[5]=-(n*a-s*i)/h,t[6]=(s*u-c*o)/h,t[7]=-(n*u-c*r)/h,t[8]=(n*o-s*r)/h,t}function fe(t,e){const[n,r,i,s,o,a,c,u,l]=e;return t[0]=n,t[1]=s,t[2]=c,t[3]=r,t[4]=o,t[5]=u,t[6]=i,t[7]=a,t[8]=l,t}function me(t,e,n){const[r,i,s,o,a,c,u,l,h]=e,[d,p,f]=n;return t[0]=r*d+o*p+u*f,t[1]=i*d+a*p+l*f,t[2]=s*d+c*p+h*f,t}function ge(t,e,n){const[r,i,s]=n;return t[0]=e[0]*r+e[3]*i+e[6]*s+e[9],t[1]=e[1]*r+e[4]*i+e[7]*s+e[10],t[2]=e[2]*r+e[5]*i+e[8]*s+e[11],t}function we(t,e){const[n,r,i,s,o,a,c,u,l]=e;return function(t,e,n,r,i,s,o,a,c,u){return t[0]=e,t[1]=n,t[2]=r,t[3]=i,t[4]=s,t[5]=o,t[6]=a,t[7]=c,t[8]=u,t}(t,n,r,i,s,o,a,c,u,l)}function ye(t=0,e=0,n=0,r=0){return[t,e,n,r]}function be(t,e,n){const[r,i,s,o]=e,[a,c,u,l]=n;return t[0]=r*a+s*c,t[1]=i*a+o*c,t[2]=r*u+s*l,t[3]=i*u+o*l,t}function ve(t,e,n){const[r,i,s,o]=e,[a,c]=n;return t[0]=r*a+s*c,t[1]=i*a+o*c,t}const Te=new s("@morkite/webgl-components/3d/CUBOID_TRAIT_TOKENS");class ke{static Unit=new ke;static FromMatrix(t){const e=new ke;return le(e.#gt,t),e}#gt;get matrix(){return this.#gt}constructor(){this.#gt=ce()}apply(t,e){return ge(t,this.#gt,e)}assign(t){return le(this.#gt,t.matrix),this}clone(){const t=new ke;return t.assign(this),t}resetToUnit(){return le(this.#gt,ue),this}applyTransform(t){return he(this.#gt,t.matrix,this.matrix),this}applyTransformWithin(t){return he(this.#gt,this.matrix,t.matrix),this}scale(t,e,n){var r,i,s,o;return r=this.#gt,i=t,s=e,o=n,r[0]*=i,r[1]*=s,r[2]*=o,r[3]*=i,r[4]*=s,r[5]*=o,r[6]*=i,r[7]*=s,r[8]*=o,r[9]*=i,r[10]*=s,r[11]*=o,this}scaleWithin(t,e,n){var r,i,s,o;return r=this.#gt,i=t,s=e,o=n,r[0]*=i,r[1]*=i,r[2]*=i,r[3]*=s,r[4]*=s,r[5]*=s,r[6]*=o,r[7]*=o,r[8]*=o,this}translate(t,e,n){return function(t,e,n,r){t[9]+=e,t[10]+=n,t[11]+=r}(this.#gt,t,e,n),this}translateVia(t){const[e,n,r]=t;return this.translate(e,n,r)}translateWithin(t,e,n){return function(t,e,n,r){t[9]+=t[0]*e+t[3]*n+t[6]*r,t[10]+=t[1]*e+t[4]*n+t[7]*r,t[11]+=t[2]*e+t[5]*n+t[8]*r}(this.#gt,t,e,n),this}translateWithinVia(t){const[e,n,r]=t;return this.translateWithin(e,n,r)}rotateAroundX(t){return function(t,e){const n=Math.cos(e),r=Math.sin(e),[i,s,o,a,c,u,l,h,d,p,f,m]=t;t[0]=i,t[1]=n*s-r*o,t[2]=r*s+n*o,t[3]=a,t[4]=n*c-r*u,t[5]=r*c+n*u,t[6]=l,t[7]=n*h-r*d,t[8]=r*h+n*d,t[9]=p,t[10]=n*f-r*m,t[11]=r*f+n*m}(this.#gt,t),this}rotateAroundY(t){return function(t,e){const n=Math.cos(e),r=Math.sin(e),[i,s,o,a,c,u,l,h,d,p,f,m]=t;t[0]=n*i+r*o,t[1]=s,t[2]=-r*i+n*o,t[3]=a,t[4]=c,t[5]=u,t[6]=n*l+r*d,t[7]=h,t[8]=-r*l+n*d,t[9]=n*p+r*m,t[10]=f,t[11]=-r*p+n*m}(this.#gt,t),this}rotateAroundZ(t){return function(t,e){const n=Math.cos(e),r=Math.sin(e),[i,s,o,a,c,u,l,h,d,p,f,m]=t;t[0]=n*i-r*s,t[1]=r*i+n*s,t[2]=o,t[3]=n*a-r*c,t[4]=r*a+n*c,t[5]=u,t[6]=n*l-r*h,t[7]=r*l+n*h,t[8]=d,t[9]=n*p-r*f,t[10]=r*p+n*f,t[11]=m}(this.#gt,t),this}inverse(){return function(t,e){const[n,r,i,s,o,a,c,u,l,h,d,p]=e,f=[n,r,i,s,o,a,c,u,l];pe(f,f);const m=[h,d,p];me(m,f,m),zt(m,m),function(t,e,n,r,i,s,o,a,c,u,l,h,d){t[0]=e,t[1]=n,t[2]=r,t[3]=i,t[4]=s,t[5]=o,t[6]=a,t[7]=c,t[8]=u,t[9]=l,t[10]=h,t[11]=d}(t,...f,...m)}(this.#gt,this.matrix),this}toString(){return`Transform3[${this.#gt.join("|")}]`}}class xe{#M;#wt;constructor(t,e){this.#M=t,this.#wt=e}onProcessorCreated(){}onFrameStart(){}process(t,{renderer:e,frameStorage:n}){const r=n.get(this.#wt.worldTransform)??ke.Unit,i=t.get(this.#M.geometry),s=t.get(this.#M.geometryElements),o=t.get(this.#M.vertexNormals);if(null==i&&null==s&&null==o)return W.Instance;if(null==i||null==s||null==o)return W.Instance;let a=e.canAttributeBufferAccommodate(i.length);if(a&&=e.canElementsBufferAccommodate(s.length),!a)return new De;const c=i.map((t=>jt(Vt(),t))).map((t=>r.apply(t,t))),u=we(de(),r.matrix);pe(u,u),fe(u,u);const l=o.map((t=>jt(Vt(),t))).map((t=>me(t,u,t)));return new Ce(t,e,c,l,s,this.#M)}createBreakCommand(){return new De}onFrameFinish(){}}class Ce extends ${nugget;renderer;worldPosition;vertexNormals;elements;traitTokens;constructor(t,e,n,r,i,s){super(!1),this.nugget=t,this.renderer=e,this.worldPosition=n,this.vertexNormals=r,this.elements=i,this.traitTokens=s}execute(){const t=this.nugget.get(this.traitTokens.tintColor)??P.White;for(let e=0;e<this.worldPosition.length;e++)this.renderer.writeToAttributeBuffer(this.worldPosition[e],this.vertexNormals[e],t);this.renderer.writeToElementsBuffer(this.worldPosition.length,this.elements)}}class De extends ${constructor(){super(!0)}execute(){}}class Ee{onProcessorCreated(){}onFrameStart({renderer:t}){t.clearColorBufferBit()}process(){return W.Instance}createBreakCommand(){return j.Instance}onFrameFinish(){}}class Ie{#M;#wt;constructor(t,e){this.#M=t,this.#wt=e}onProcessorCreated(){}onFrameStart(t){t.frameStorage.set(this.#wt.worldTransform,new ke)}process(t,{frameStorage:e}){const n=t.get(this.#M.undo);if(null!=n){const t=n.get(this.#M.localTransform);if(null!=t){const n=t.clone().inverse();e.get(this.#wt.worldTransform,{onMiss:"throw"}).applyTransformWithin(n)}}const r=t.get(this.#M.localTransform);if(null!=r){const n=e.get(this.#wt.worldTransform,{onMiss:"throw"});n.applyTransformWithin(r);let i=t.get(this.#M.worldTransform);null==i&&(i=new ke,t.set(this.#M.worldTransform,i)),i.assign(n)}return W.Instance}createBreakCommand(){return j.Instance}onFrameFinish(){}}class Ae{#M;constructor(t){this.#M=t}onProcessorCreated(){}onFrameStart(){}process(t,e){const n=t.get(this.#M.projection);return null==n||e.renderer.setProjectionMatrix([...n]),W.Instance}createBreakCommand(){return j.Instance}onFrameFinish(){}}class Se{#M;constructor(t){this.#M=t}onProcessorCreated(){}onFrameStart(){}process(t,e){const n=t.get(this.#M.directionalLight);return null!=n&&e.renderer.setLightDirection([...n]),W.Instance}createBreakCommand(){return j.Instance}onFrameFinish(){}}function Fe(t,e,n){const r=t.createShader(e);if(null==r)throw new Error("Could not create a shader.");t.shaderSource(r,n),t.compileShader(r);if(!t.getShaderParameter(r,t.COMPILE_STATUS))throw console.error(t.getShaderInfoLog(r)),new Error("Could not compile the shader.");return r}function Ne(t){return{kind:"directive",text:t}}function Be(t){return{kind:"identifier",name:"string"==typeof t?t:t.name}}function Me(t){return"string"==typeof t?{kind:"identifier",name:t}:t}function Ve(t,e,n,r,i){return{kind:"storage-declaration",storageQualifier:t,type:e,name:Be(n),arrayLength:r??null,interpolationQualifier:i??null}}function Re(t,e,n,r){return{kind:"function-declaration",returnType:t,name:Be(e),parameters:n,body:r}}function Oe(t,e,n){return{kind:"assignment",operator:t,left:Me(e),right:n}}function Pe(t,e){return{kind:"function-call",functionName:Be(t),arguments:e}}function Le(t){return{kind:"comment",text:t}}function Ue(t){return{kind:"program",items:t}}class _e{print(t){switch(t.kind){case"directive":return this.printDirective(t);case"identifier":return this.printIdentifier(t);case"literal":return this.printLiteral(t);case"variable-declaration":return this.printVariableDeclaration(t);case"storage-declaration":return this.printStorageDeclaration(t);case"precision-declaration":return this.printPrecisionDeclaration(t);case"function-parameter":return this.printFunctionParameter(t);case"function-declaration":return this.printFunctionDeclaration(t);case"unary-expression":return this.printUnaryExpression(t);case"binary-expression":return this.printBinaryExpression(t);case"assignment":return this.printAssignment(t);case"function-call":return this.printFunctionCall(t);case"swizzle":return this.printSwizzle(t);case"index-expression":return this.printIndexExpression(t);case"comment":return this.printComment(t);case"switch-statement":return this.printSwitchStatement(t);case"switch-statement-case":return this.printSwitchStatementCase(t);case"break-statement":return this.printBreakStatement();case"return-statement":return this.printReturnStatement(t);case"program":return this.printProgram(t)}}printDirective(t){return`#${t.text}`}printIdentifier(t){return t.name}printLiteral(t){return t.raw}printVariableDeclaration(t){return null==t.initializer?`${t.type} ${this.printIdentifier(t.name)};`:`${t.type} ${this.printIdentifier(t.name)} = ${this.printExpression(t.initializer)};`}printStorageDeclaration(t){let e=this.printIdentifier(t.name);return null!=t.arrayLength&&(e=`${e}[${t.arrayLength}]`),e=`${t.storageQualifier} ${t.type} ${e}`,null!=t.interpolationQualifier&&(e=`${t.interpolationQualifier} ${e}`),e=`${e};`,e}printPrecisionDeclaration(t){return`precision ${t.qualifier} ${t.type};`}printFunctionParameter(t){return null==t.qualifier?`${t.type} ${this.printIdentifier(t.name)}`:`${t.qualifier} ${t.type} ${this.printIdentifier(t.name)}`}printFunctionDeclaration(t){const e=t.body.map((t=>"  "+this.printStatement(t))).join("\n"),n=t.parameters.map((t=>this.printFunctionParameter(t))).join(", ");return[`${t.returnType} ${this.printIdentifier(t.name)} (${n}) {`,e,"}"].join("\n")}printUnaryExpression(t){return`${t.operator}(${this.printExpression(t.operand)})`}printBinaryExpression(t){return`(${this.printExpression(t.leftOperand)}) ${t.operator} (${this.printExpression(t.rightOperand)})`}printFunctionCall(t){const e=t.arguments.map((t=>this.printExpression(t))).join(", ");return`${this.printIdentifier(t.functionName)}(${e})`}printExpression(t){switch(t.kind){case"literal":return this.printLiteral(t);case"identifier":return this.printIdentifier(t);case"unary-expression":return this.printUnaryExpression(t);case"binary-expression":return this.printBinaryExpression(t);case"function-call":return this.printFunctionCall(t);case"swizzle":return this.printSwizzle(t);case"index-expression":return this.printIndexExpression(t)}}printAssignment(t){return`${this.printExpression(t.left)} ${t.operator} ${this.printExpression(t.right)};`}printSwizzle(t){return`(${this.printExpression(t.target)}).${t.mask}`}printIndexExpression(t){return`(${this.printExpression(t.target)})[${this.printExpression(t.index)}]`}printComment(t){return t.text.split("\n").map((t=>`// ${t}`)).join("\n")}printSwitchStatement(t){let e=`switch (${this.printExpression(t.discriminant)}) {`;for(const n of t.cases)e+=`\n  ${this.printSwitchStatementCase(n)}`;return e+="\n}",e}printSwitchStatementCase(t){let e=null==t.test?"default: {":`case ${this.printExpression(t.test)}: {`;for(const n of t.consequences)e+=`\n  ${this.printStatement(n)}`;return e+="\n}",e}printBreakStatement(){return"break;"}printReturnStatement(t){return`return ${this.printExpression(t.expression)};`}printStatement(t){switch(t.kind){case"assignment":return this.printAssignment(t);case"variable-declaration":return this.printVariableDeclaration(t);case"comment":return this.printComment(t);case"switch-statement":return this.printSwitchStatement(t);case"break-statement":return this.printBreakStatement();case"return-statement":return this.printReturnStatement(t)}}printTopLevelDeclaration(t){switch(t.kind){case"storage-declaration":return this.printStorageDeclaration(t);case"precision-declaration":return this.printPrecisionDeclaration(t)}}printTopLevelItem(t){switch(t.kind){case"storage-declaration":case"precision-declaration":return this.printTopLevelDeclaration(t);case"function-declaration":return this.printFunctionDeclaration(t);case"directive":return this.printDirective(t);case"comment":return this.printComment(t)}}printProgram(t){return t.items.map((t=>this.printTopLevelItem(t))).join("\n")}}class $e{glslSpecifier;constructor(t){this.glslSpecifier=t}}class We extends $e{kind="primitive";glslSpecifier;constructor(t){super(t),this.glslSpecifier=t}}new We("int");const je=new We("float");new We("vec2");const ze=new We("vec3"),Ke=new We("vec4");new We("mat3");const Ge=new We("mat4");new We("sampler2D");class He{static Simply(t){const e=new He;return e.expressions.push(t),e}dependencies=new Array;expressions=new Array;get singleSelfContainedExpression(){if(this.dependencies.length>0)throw new Error("Not implemented.");if(this.expressions.length>1)throw new Error("Not implemented.");if(0==this.expressions.length)throw new Error("No outputs?");return this.expressions[0]}}class qe{#yt=0;taken=new Set;isTaken(t){return this.taken.has(t)}markAsTaken(t){if(this.isTaken(t))throw new Error(`The name “${t}” is already taken.`);this.taken.add(t)}spawnAndMarkAsTaken(){for(;;){const t="temp_"+this.#yt++;if(!this.isTaken(t))return this.markAsTaken(t),t}}spawnManyAndMarkAsTaken(t){const e=new Array;for(let n=0;n<t;n++)e.push(this.spawnAndMarkAsTaken());return e}}class Ye{type;graphNode;index;constructor(t,e,n){this.type=t,this.graphNode=e,this.index=n}}class Xe{definition;graphNodeInstance;constructor(t,e){this.definition=t,this.graphNodeInstance=e}#bt=null;get incomingConnection(){return this.#bt}connectFrom(t,e=!1){if(null!=this.#bt)throw new Error("Input already connected. This error could mean an invalid state (TODO).");this.#bt=t,e||t.connectTo(this,!0)}removeIncomingConnection(t=!1){if(null==this.#bt)throw new Error("Input not connected. This error could mean an invalid state (TODO).");t||this.#bt.removeOutgoingConnection(this,!0);const e=this.#bt;return this.#bt=null,e}#vt=new Set;get outgoingConnections(){return this.#vt}connectTo(t,e=!1){if(this.#vt.has(t))throw new Error("Already connected to that input. This error could mean an invalid state (TODO).");this.#vt.add(t),e||t.connectFrom(this,!0)}removeOutgoingConnection(t,e=!1){if(!this.#vt.has(t))throw new Error("Not connected to that input. This error could mean an invalid state (TODO).");return e||t.removeIncomingConnection(!0),this.#vt.delete(t),t}}class Qe{definition;inputLinks;outputLinks;get inputs(){return this.inputLinks}get outputs(){return this.outputLinks}constructor(t){this.definition=t,this.inputLinks=t.inputs.map((t=>new Xe(t,this))),this.outputLinks=t.outputs.map((t=>new Xe(t,this)))}}class Ze{inputTypes;outputTypes;inputs;outputs;constructor(t,e){this.inputTypes=t,this.outputTypes=e,this.inputs=t.map(((t,e)=>new Ye(t,this,e))),this.outputs=e.map(((t,e)=>new Ye(t,this,e)))}createInstance(){return new Qe(this)}}class Je extends Ze{constructor(){super([je,je,je],[je])}generateAst(t,e,n,r){return He.Simply(Pe("clamp",[e,n,r]))}}class tn{#Tt;#kt;constructor(t,e){this.#Tt=t,this.#kt=e}*initiallyScheduledLinks(){for(const t of this.#Tt.inputs)yield{kind:"input",link:t}}finalize(t,e,n){if(e.size!=this.#Tt.inputs.length)throw new Error(`workbench left with ${e.size} items in the end, bug. expected ${this.#Tt.inputs.length} which matches the number of inputs of this intermediate node.`);const r=new Array;for(;e.size>0;)r.push(e.popFromFront());const i=this.#Tt.definition.generateAst(n,...r);t.dependencies.push(...i.dependencies);let s=0;for(const e of this.#kt){const n=this.#Tt.outputs[s].definition.type,r=(o=n.glslSpecifier,a=Be(e),c=i.expressions[s],{kind:"variable-declaration",type:o,name:Be(a),initializer:c??null});t.dependencies.push(r),s++}var o,a,c}getOutputNameFor(t){if(!this.#Tt.outputs.includes(t))throw new Error("Not an output for this node?");return this.#kt[t.definition.index]}}class en{#xt;constructor(t){this.#xt=Array.from(t)}*initiallyScheduledLinks(){for(const t of this.#xt)yield{kind:"input",link:t}}finalize(t,e){if(e.size!=this.#xt.length)throw new Error(`workbench left with ${e.size} items in the end, bug. expected ${this.#xt.length}, which matches the number of outputs of this node`);for(;e.size>0;)t.expressions.push(e.popFromFront())}}class nn{definition;graphNodeInstance;constructor(t,e){this.definition=t,this.graphNodeInstance=e}#vt=new Set;get outgoingConnections(){return this.#vt}connectTo(t,e=!1){if(this.#vt.has(t))throw new Error("Already connected to that input. This error could mean an invalid state (TODO).");this.#vt.add(t),e||t.connectFrom(this,!0)}removeOutgoingConnection(t,e=!1){if(!this.#vt.has(t))throw new Error("Not connected to that input. This error could mean an invalid state (TODO).");return e||t.removeIncomingConnection(!0),this.#vt.delete(t),t}}class rn{definition;graphNodeInstance;constructor(t,e){this.definition=t,this.graphNodeInstance=e}#bt=null;get incomingConnection(){return this.#bt}connectFrom(t,e=!1){if(null!=this.#bt)throw new Error("Input already connected. This error could mean an invalid state (TODO).");this.#bt=t,e||t.connectTo(this,!0)}removeIncomingConnection(t=!1){if(null==this.#bt)throw new Error("Input not connected. This error could mean an invalid state (TODO).");t||this.#bt.removeOutgoingConnection(this,!0);const e=this.#bt;return this.#bt=null,e}}class sn extends Ze{inputDefinitions;outputDefinitions;#Ct;constructor(t,e){super(t,e),this.#Ct=this.createInstance(),this.inputDefinitions=this.inputs.map((t=>new nn(t,this.#Ct))),this.outputDefinitions=this.outputs.map((t=>new rn(t,this.#Ct)))}generateAst(t,...e){return function(t,e,n,r){const i=new He,s=new Map,o=new _;for(o.pushToFront(new en(t));o.size>0;){const t=o.popFromFront(),a=new _,c=new _;for(const e of t.initiallyScheduledLinks())c.pushToFront(e);for(;c.size>0;){const t=c.popFromFront();if("input"==t.kind){if(null==t.link.incomingConnection)throw new Error(`broken graph? looks like ${t.link.definition.graphNode.constructor.name}'s input ${t.link.definition.index} is not connected to anything`);if(e(t.link.incomingConnection.definition.graphNode)){const e=r[t.link.incomingConnection.definition.index];if(null==e)throw new Error("not enough input expressions");a.pushToFront(e)}else{const e=t.link.incomingConnection.outgoingConnections.size>1,r=t.link.incomingConnection.definition.graphNode.outputs.length>1;if(e||r){let e=s.get(t.link.incomingConnection.graphNodeInstance);null==e&&(e=new tn(t.link.incomingConnection.graphNodeInstance,n.spawnManyAndMarkAsTaken(t.link.incomingConnection.definition.graphNode.outputs.length)),s.set(t.link.incomingConnection.graphNodeInstance,e),o.pushToFront(e));const r=e.getOutputNameFor(t.link.incomingConnection);a.pushToFront(Be(r))}else{c.pushToFront({kind:"output",link:t.link.incomingConnection});for(let e=t.link.incomingConnection.definition.graphNode.inputs.length-1;e>=0;e-=1){const n=t.link.incomingConnection.graphNodeInstance.inputs[e];c.pushToFront({kind:"input",link:n})}}}}else if("output"==t.kind){const e=new Array;for(let n=0;n<t.link.definition.graphNode.inputs.length;n++){const t=a.popFromFront();if(null==t)throw new Error("not enough things on the workbench, algorithm error, bug");e.unshift(t)}const r=t.link.definition.graphNode.generateAst(n,...e);if(1!=r.expressions.length)throw new Error("shouldn't be on the stack if there's more than one expression (it would've started a new dependency for multi-output), and it wouldn't be discovered if it had no outputs (which is weird in its own merit)");i.dependencies.push(...r.dependencies),a.pushToFront(r.expressions[0])}}t.finalize(i,a,n)}return i}(this.outputDefinitions,(t=>t==this),t,e)}print(t=on.Instance){const e=new Array,n=new Set;n.add(this.#Ct);const r=new _;for(const t of this.inputDefinitions)r.pushToBack(t);for(;r.size>0;){const i=r.popFromFront(),s=i.graphNodeInstance==this.#Ct?t.printHostInput(i.graphNodeInstance.definition,i.definition):t.printInnerOutput(i.graphNodeInstance.definition,i.definition),o=new Array;for(const e of i.outgoingConnections){const i=e.graphNodeInstance==this.#Ct?t.printHostOutput(e.graphNodeInstance.definition,e.definition):t.printInnerInput(e.graphNodeInstance.definition,e.definition);if(o.push(i),!n.has(e.graphNodeInstance)){n.add(e.graphNodeInstance);for(const t of e.graphNodeInstance.outputs)r.pushToBack(t)}}e.push(`${s} -> ${o.join(", ")}`)}return e.join("\n")}}class on{static Instance=new on;printHostInput(t,e){return`$.in.${cn(e)}`}printHostOutput(t,e){return`$.out.${cn(e)}`}printInnerInput(t,e){return`${an(t)}.in.${cn(e)}`}printInnerOutput(t,e){return`${an(t)}.out.${cn(e)}`}}function an(t){return t.constructor.name}function cn(t){return t.index.toString()}class un extends Ze{#Dt;constructor(t,e){super([],[t]),this.#Dt=function(t){return{kind:"literal",raw:"string"==typeof t?t:t.raw}}(e)}generateAst(){return He.Simply(this.#Dt)}}class ln extends Ze{constructor(t){super([t,t],[je])}generateAst(t,e,n){return He.Simply(Pe("dot",[e,n]))}}class hn extends Ze{constructor(t){super([t],[t])}generateAst(t,e){return He.Simply(e)}}class dn extends Ze{constructor(t,e,n){super([t,e],[n])}generateAst(t,e,n){return He.Simply({kind:"binary-expression",operator:"*",leftOperand:e,rightOperand:n})}}class pn extends Ze{constructor(t){super([t],[t])}generateAst(t,e){return He.Simply({kind:"unary-expression",operator:"-",operand:e})}}class fn extends Ze{constructor(t){super([t],[t])}generateAst(t,e){return He.Simply(Pe("normalize",[e]))}}class mn extends Ze{static Create(t,e,n){return new mn(t,e,n)}mask;constructor(t,e,n){super([t],[e]),this.mask=n}generateAst(t,e){return He.Simply((n=e,r=this.mask,{kind:"swizzle",target:Me(n),mask:r}));var n,r}}class gn extends Ze{constructor(t,e){super(t,[e])}generateAst(t,...e){return He.Simply(Pe(this.outputs[0].type.glslSpecifier,e))}}class wn{kind="attribute";#t;type;constructor(t,e){this.#t=t,this.type=e}createVertexShaderReference(){return Be(this.#t)}createFragmentShaderReference(){throw new Error("Oops!")}createVertexShaderDeclaration(){return"array"==this.type.kind?Ve("in",this.type.elementType.glslSpecifier,this.#t,this.type.length):Ve("in",this.type.glslSpecifier,this.#t,null)}createFragmentShaderDeclaration(){throw new Error("Oops!")}getLocation(t,e){return t.getAttribLocation(e,this.#t)}isCompatibleInterpreter(t){return!0}print(){return`attribute/${this.#t}`}}class yn{static From(t,e,n){const r=n.getLocation(t,e);return new yn(n,r)}definition;#Et;constructor(t,e){this.definition=t,this.#Et=e}describeLayout(t,e,n){t.enableVertexAttribArray(this.#Et),t.vertexAttribPointer(this.#Et,e.componentsCount,e.dataType.glConstant,e.normalized,n.vertexByteSize,n.getByteOffsetViaAttribute(this))}}class bn{kind="uniform";#t;type;constructor(t,e){this.#t=t,this.type=e}createReference(){return Be(this.#t)}createVertexShaderReference(){return this.createReference()}createFragmentShaderReference(){return this.createReference()}createDeclaration(){return"array"==this.type.kind?Ve("uniform",this.type.elementType.glslSpecifier,this.#t,this.type.length):Ve("uniform",this.type.glslSpecifier,this.#t,null)}createVertexShaderDeclaration(){return this.createDeclaration()}createFragmentShaderDeclaration(){return this.createDeclaration()}getLocation(t,e){return t.getUniformLocation(e,this.#t)}print(){return`uniform/${this.#t}`}}class vn{definition;glLocation;constructor(t,e){this.definition=t,this.glLocation=e}}class Tn extends vn{static From(t,e,n){const r=n.getLocation(t,e);if(null==r)throw new Error("Not implemented.");return new Tn(n,r)}set(t,e){t.uniformMatrix4fv(this.glLocation,!1,e)}}class kn extends vn{static From(t,e,n){const r=n.getLocation(t,e);if(null==r)throw new Error("Not implemented.");return new kn(n,r)}set(t,e){t.uniform3fv(this.glLocation,e)}}class xn{kind="varying";#t;type;#It;constructor(t,e,n){this.#t=t,this.type=e,this.#It=n?.interpolationQualifier??null}createReference(){return Be(this.#t)}createVertexShaderReference(){return this.createReference()}createFragmentShaderReference(){return this.createReference()}createDeclaration(t){return"array"==this.type.kind?Ve(t,this.type.elementType.glslSpecifier,this.#t,this.type.length,this.#It):Ve(t,this.type.glslSpecifier,this.#t,null,this.#It)}createVertexShaderDeclaration(){return this.createDeclaration("out")}createFragmentShaderDeclaration(){return this.createDeclaration("in")}print(){return`varying/${this.#t}`}}class Cn extends sn{constructor(){super([ze,ze,Ke],[Ke]);const t=new fn(ze).createInstance(),e=new fn(ze).createInstance(),n=new pn(ze).createInstance(),r=new ln(ze).createInstance(),i=(new Je).createInstance(),s=mn.Create(Ke,ze,"rgb").createInstance(),o=mn.Create(Ke,je,"a").createInstance(),a=new dn(je,ze,ze).createInstance(),c=new gn([ze,je],Ke).createInstance();this.inputDefinitions[0].connectTo(t.inputs[0]),this.inputDefinitions[1].connectTo(e.inputs[0]),e.outputs[0].connectTo(n.inputs[0]),t.outputs[0].connectTo(r.inputs[0]),n.outputs[0].connectTo(r.inputs[1]),r.outputs[0].connectTo(i.inputs[0]),new un(je,"0.0").createInstance().outputs[0].connectTo(i.inputs[1]),new un(je,"1.0").createInstance().outputs[0].connectTo(i.inputs[2]),i.outputs[0].connectTo(a.inputs[0]),this.inputDefinitions[2].connectTo(s.inputs[0]),s.outputs[0].connectTo(a.inputs[1]),a.outputs[0].connectTo(c.inputs[0]),this.inputDefinitions[2].connectTo(o.inputs[0]),o.outputs[0].connectTo(c.inputs[1]),c.outputs[0].connectTo(this.outputDefinitions[0])}}class Dn{kind="implicit-varying";type=Ke;createVertexShaderReference(){return Be("gl_Position")}createFragmentShaderReference(){return Be("gl_FragCoord")}createVertexShaderDeclaration(){return Le("out vec4 gl_Position (implicit)")}createFragmentShaderDeclaration(){return Le("in vec4 gl_FragCoord (implicit)")}print(){return"implicit_varying"}}class En{#t;type;constructor(t,e){this.#t=t,this.type=e}createReference(){return Be(this.#t)}createVertexShaderReference(){throw new Error("Oops!")}createFragmentShaderReference(){return this.createReference()}createDeclaration(){return"array"==this.type.kind?Ve("out",this.type.elementType.glslSpecifier,this.#t,this.type.length):Ve("out",this.type.glslSpecifier,this.#t,null)}createVertexShaderDeclaration(){throw new Error("Oops!")}createFragmentShaderDeclaration(){return this.createDeclaration()}print(){return`fragment_output/${this.#t}`}}class In{#At;#o=new Map;#St=new Map;constructor(t){this.#At=t}set(t,e){if(e.graphNode!==this.#At)throw new Error("Oops!");if(this.#o.has(t))throw new Error("Oops!");if(this.#St.has(e))throw new Error("Oops!");this.#o.set(t,e),this.#St.set(e,t)}get(t){return this.#o.get(t)??null}getReverse(t){return this.#St.get(t)??null}*[Symbol.iterator](){for(const t of this.#At.inputs){const e=this.getReverse(t);yield[e,t]}}*inputDefinitions(){for(const[t]of this)null!=t&&(yield t)}*linkDefinitions(){for(const[,t]of this)yield t}}class An{#At;#o=new Map;#St=new Map;constructor(t){this.#At=t}set(t,e){if(e.graphNode!==this.#At)throw new Error("Oops!");if(this.#o.has(t))throw new Error("Oops!");if(this.#St.has(e))throw new Error("Oops!");this.#o.set(t,e),this.#St.set(e,t)}get(t){return this.#o.get(t)??null}getReverse(t){return this.#St.get(t)??null}*[Symbol.iterator](){for(const t of this.#At.outputs){const e=this.getReverse(t);yield[e,t]}}*outputDefinitions(){for(const[t]of this)t&&(yield t)}*linkDefinitions(){for(const[,t]of this)yield t}}class Sn{static Create(t,e,n){return new Sn(t,e,n)}#At;#Ft;#Nt;get nodeDefinition(){return this.#At}get inputVariables(){return this.#Ft}get outputVariables(){return this.#Nt}constructor(t,e,n){this.#At=t,this.#Ft=new In(t),this.#Nt=new An(t);for(const[n,r]of e.entries())this.#Ft.set(r,t.inputs[n]);for(const[e,r]of n.entries())this.#Nt.set(r,t.outputs[e])}createAndCompileGlShader(t,e){const n=new qe,r=this.#At.inputs.map((t=>this.#Ft.getReverse(t).createVertexShaderReference())),i=this.#At.generateAst(n,...r),s=this.#At.outputs.map((t=>this.#Nt.getReverse(t).createVertexShaderReference())),o=Ue([Ne("version 300 es"),...this.#At.inputs.map((t=>this.#Ft.getReverse(t).createVertexShaderDeclaration())),...this.#At.outputs.map((t=>this.#Nt.getReverse(t).createVertexShaderDeclaration())),Re("void","main",[],[...i.dependencies,...i.expressions.map(((t,e)=>Oe("=",s[e],t)))])]),a=t.print(o);return Fe(e,e.VERTEX_SHADER,a)}print(){if(this.#At instanceof sn)return this.#At.print(new Fn(this.inputVariables,this.outputVariables));throw new Error("Oops!")}applyModifications(...t){return t.reduce(((t,e)=>e.applyTo(t)),this)}}class Fn extends on{#Ft;#Nt;constructor(t,e){super(),this.#Ft=t,this.#Nt=e}printHostInput(t,e){const n=this.#Ft.getReverse(e),r=null==n?"":"/"+n.print();return super.printHostInput(t,e)+r}printHostOutput(t,e){const n=this.#Nt.getReverse(e),r=null==n?"":"/"+n.print();return super.printHostOutput(t,e)+r}printInnerInput(t,e){return super.printInnerInput(t,e)}printInnerOutput(t,e){return super.printInnerOutput(t,e)}}class Nn{#At;#o=new Map;#St=new Map;constructor(t){this.#At=t}set(t,e){if(e.graphNode!==this.#At)throw new Error("Oops!");if(this.#o.has(t))throw new Error("Oops!");if(this.#St.has(e))throw new Error("Oops!");this.#o.set(t,e),this.#St.set(e,t)}get(t){return this.#o.get(t)??null}getReverse(t){return this.#St.get(t)??null}*[Symbol.iterator](){for(const t of this.#At.inputs){const e=this.getReverse(t);yield[e,t]}}*inputDefinitions(){for(const[t]of this)null!=t&&(yield t)}*linkDefinitions(){for(const[,t]of this)yield t}}class Bn{#At;#o=new Map;#St=new Map;constructor(t){this.#At=t}set(t,e){if(e.graphNode!==this.#At)throw new Error("Oops!");if(this.#o.has(t))throw new Error("Oops!");if(this.#St.has(e))throw new Error("Oops!");this.#o.set(t,e),this.#St.set(e,t)}get(t){return this.#o.get(t)??null}getReverse(t){return this.#St.get(t)??null}*[Symbol.iterator](){for(const t of this.#At.outputs){const e=this.getReverse(t);yield[e,t]}}*outputDefinitions(){for(const[t]of this)t&&(yield t)}*linkDefinitions(){for(const[,t]of this)yield t}}class Mn{static Create(t,e,n){return new Mn(t,e,n)}#At;#Ft;#Nt;get nodeDefinition(){return this.#At}get inputVariables(){return this.#Ft}get outputVariables(){return this.#Nt}constructor(t,e,n){this.#At=t,this.#Ft=new Nn(t),this.#Nt=new Bn(t);for(const[n,r]of e.entries())this.#Ft.set(r,t.inputs[n]);for(const[e,r]of n.entries())this.#Nt.set(r,t.outputs[e])}createAndCompileGlShader(t,e){const n=new qe,r=this.#At.inputs.map((t=>this.#Ft.getReverse(t).createFragmentShaderReference())),i=this.#At.generateAst(n,...r),s=this.#At.outputs.map((t=>this.#Nt.getReverse(t).createFragmentShaderReference())),o=Ue([Ne("version 300 es"),(a="highp",c="float",{kind:"precision-declaration",qualifier:a,type:c}),...this.#At.inputs.map((t=>this.#Ft.getReverse(t).createFragmentShaderDeclaration())),...this.#At.outputs.map((t=>this.#Nt.getReverse(t).createFragmentShaderDeclaration())),Re("void","main",[],[...i.dependencies,...i.expressions.map(((t,e)=>Oe("=",s[e],t)))])]);var a,c;const u=t.print(o);return Fe(e,e.FRAGMENT_SHADER,u)}print(){if(this.#At instanceof sn)return this.#At.print(new Vn(this.inputVariables,this.outputVariables));throw new Error("Oops!")}applyModifications(...t){return t.reduce(((t,e)=>e.applyTo(t)),this)}}class Vn extends on{#Ft;#Nt;constructor(t,e){super(),this.#Ft=t,this.#Nt=e}printHostInput(t,e){const n=this.#Ft.getReverse(e),r=null==n?"":"/"+n.print();return super.printHostInput(t,e)+r}printHostOutput(t,e){const n=this.#Nt.getReverse(e),r=null==n?"":"/"+n.print();return super.printHostOutput(t,e)+r}printInnerInput(t,e){return super.printInnerInput(t,e)}printInnerOutput(t,e){return super.printInnerOutput(t,e)}}class Rn{}class On extends Rn{static Create(t,e,n){return new On(t,e,n)}#At;#Ft;#Nt;constructor(t,e,n){super(),this.#At=t,this.#Ft=new In(t),this.#Nt=new An(t);for(const[n,r]of e.entries())this.#Ft.set(r,t.inputs[n]);for(const[e,r]of n.entries())this.#Nt.set(r,t.outputs[e])}applyTo(t){const e=this;for(const e of t.outputVariables.outputDefinitions())for(const t of this.#Nt.outputDefinitions())if(e==t)throw new Error("Oops!");const n=Array.from(this.#Nt.linkDefinitions()),r=new Map,i=new Array;for(const[e,n]of this.#Ft){const s=t.inputVariables.get(e);null==s?i.push(n):r.set(e,s)}const s=new class extends sn{constructor(){super([...t.nodeDefinition.inputTypes,...i.map((({type:t})=>t))],[...t.nodeDefinition.outputTypes,...n.map((({type:t})=>t))]);const s=t.nodeDefinition.createInstance(),o=e.#At.createInstance();for(let e=0;e<t.nodeDefinition.inputs.length;e++)this.inputDefinitions[e].connectTo(s.inputs[e]);for(const[t,n]of r){const r=e.#Ft.get(t);if(null==r)throw new Error("Expected “modInputLink” to be non-nullish.");const i=o.inputs[r.index];this.inputDefinitions[n.index].connectTo(i)}for(const[e,n]of i.entries()){const r=o.inputs[n.index];this.inputDefinitions[t.nodeDefinition.inputs.length+e].connectTo(r)}for(let e=0;e<t.nodeDefinition.outputs.length;e++)s.outputs[e].connectTo(this.outputDefinitions[e]);for(const[e,r]of n.entries()){const n=o.outputs[r.index],i=this.outputDefinitions[t.nodeDefinition.outputs.length+e];n.connectTo(i)}}};return new Sn(s,[...t.inputVariables.inputDefinitions(),...i.map((t=>e.#Ft.getReverse(t)))],[...t.outputVariables.outputDefinitions(),...n.map((t=>e.#Nt.getReverse(t)))])}}class Pn extends Rn{static Create(t,e,n){return new Pn(t,e,n)}#At;#Ft;#Bt;constructor(t,e,n){super(),this.#At=t,this.#Ft=new In(t),this.#Bt=n;for(const[n,r]of e.entries())this.#Ft.set(r,t.inputs[n])}applyTo(t){const e=t.outputVariables.get(this.#Bt);if(null==e)throw new Error("Oops!");const n=this,r=new Map,i=new Array;for(const[e,n]of this.#Ft){if(null==e)continue;const s=t.inputVariables.get(e);null==s?i.push(n):r.set(e,s)}const s=new class extends sn{constructor(){super([...t.nodeDefinition.inputTypes,...i.map((({type:t})=>t))],[...t.nodeDefinition.outputTypes]);const s=t.nodeDefinition.createInstance(),o=n.#At.createInstance();for(let e=0;e<t.nodeDefinition.inputs.length;e++)this.inputDefinitions[e].connectTo(s.inputs[e]);for(const[t,e]of r){const r=n.#Ft.get(t);if(null==r)throw new Error("Expected “modInputLink” to be non-nullish.");const i=o.inputs[r.index];this.inputDefinitions[e.index].connectTo(i)}for(const[e,n]of i.entries()){const r=o.inputs[n.index];this.inputDefinitions[t.nodeDefinition.inputs.length+e].connectTo(r)}for(let n=0;n<t.nodeDefinition.outputs.length;n++)n==e.index?(s.outputs[n].connectTo(o.inputs[o.definition.inputs.length-1]),o.outputs[0].connectTo(this.outputDefinitions[n])):s.outputs[n].connectTo(this.outputDefinitions[n])}};return new Sn(s,[...t.inputVariables.inputDefinitions(),...i.map((t=>n.#Ft.getReverse(t)))],[...t.outputVariables.outputDefinitions()])}}class Ln{}class Un extends Ln{static Create(t,e,n){return new Un(t,e,n)}#At;#Ft;#Bt;constructor(t,e,n){super(),this.#At=t,this.#Ft=new Nn(t),this.#Bt=n;for(const[n,r]of e.entries())this.#Ft.set(r,t.inputs[n])}applyTo(t){const e=t.outputVariables.get(this.#Bt);if(null==e)throw new Error("Oops!");const n=this,r=new Map,i=new Array;for(const[e,n]of this.#Ft){if(null==e)continue;const s=t.inputVariables.get(e);null==s?i.push(n):r.set(e,s)}const s=new class extends sn{constructor(){super([...t.nodeDefinition.inputTypes,...i.map((({type:t})=>t))],[...t.nodeDefinition.outputTypes]);const s=t.nodeDefinition.createInstance(),o=n.#At.createInstance();for(let e=0;e<t.nodeDefinition.inputs.length;e++)this.inputDefinitions[e].connectTo(s.inputs[e]);for(const[t,e]of r){const r=n.#Ft.get(t);if(null==r)throw new Error("Expected “modInputLink” to be non-nullish.");const i=o.inputs[r.index];this.inputDefinitions[e.index].connectTo(i)}for(const[e,n]of i.entries()){const r=o.inputs[n.index];this.inputDefinitions[t.nodeDefinition.inputs.length+e].connectTo(r)}for(let n=0;n<t.nodeDefinition.outputs.length;n++)n==e.index?(s.outputs[n].connectTo(o.inputs[o.definition.inputs.length-1]),o.outputs[0].connectTo(this.outputDefinitions[n])):s.outputs[n].connectTo(this.outputDefinitions[n])}};return new Mn(s,[...t.inputVariables.inputDefinitions(),...i.map((t=>n.#Ft.getReverse(t)))],[...t.outputVariables.outputDefinitions()])}}class _n{glProgram;attributes;uniforms;#Mt=new wn("a_VertexPosition",Ke);#Vt=new wn("a_VertexNormal",ze);#Rt=new wn("a_VertexColor",Ke);#Ot=new bn("u_ProjectionMatrix",Ge);#Pt=new bn("u_LightDirection",ze);#Lt=new xn("v_FragmentNormal",ze);#Ut=new xn("v_FragmentColor",Ke);#_t=new Dn;#$t=new En("out_Color",Ke);constructor(t){const e=Sn.Create(new hn(Ke),[this.#Mt],[this.#_t]),n=Pn.Create(new dn(Ge,Ke,Ke),[this.#Ot],this.#_t),r=On.Create(new hn(ze),[this.#Vt],[this.#Lt]),i=On.Create(new hn(Ke),[this.#Rt],[this.#Ut]),s=e.applyModifications(n,r,i),o=Mn.Create(new hn(Ke),[this.#Ut],[this.#$t]),a=Un.Create(new Cn,[this.#Pt,this.#Lt],this.#$t),c=o.applyModifications(a),u=new _e,l=function(t,e,n){const r=t.createProgram();if(null==r)throw new Error("Expected glProgram to be non-null.");if(t.attachShader(r,e),t.attachShader(r,n),t.linkProgram(r),!t.getProgramParameter(r,t.LINK_STATUS))throw console.error(t.getProgramInfoLog(r)),new Error("Oops!");return r}(t,s.createAndCompileGlShader(u,t),c.createAndCompileGlShader(u,t));this.glProgram=l,this.attributes={worldPosition:yn.From(t,l,this.#Mt),vertexNormal:yn.From(t,l,this.#Vt),tintColor:yn.From(t,l,this.#Rt)},this.uniforms={projectionMatrix:Tn.From(t,l,this.#Ot),lightDirection:kn.From(t,l,this.#Pt)}}}var $n;!function(t){t[t.BYTE=5120]="BYTE",t[t.UNSIGNED_BYTE=5121]="UNSIGNED_BYTE",t[t.SHORT=5122]="SHORT",t[t.UNSIGNED_SHORT=5123]="UNSIGNED_SHORT",t[t.INT=5124]="INT",t[t.UNSIGNED_INT=5125]="UNSIGNED_INT",t[t.FLOAT=5126]="FLOAT"}($n||($n={}));class Wn{get byteSize(){return this.componentsCount*this.dataType.byteSize}}class jn extends Wn{static Create(t){return new jn(t)}componentsCount;dataType={glConstant:$n.FLOAT,byteSize:4};normalized=!1;constructor(t){super(),this.componentsCount=t}}class zn extends Wn{static Create(t,e){return new zn(t,e)}componentsCount;dataType={glConstant:$n.UNSIGNED_BYTE,byteSize:1};normalized;constructor(t,e){super(),this.componentsCount=t,this.normalized=e?.normalized??!1}}class Kn{#Wt=new Map;add(t,e){if(this.#Wt.has(t))throw new Error("Oops!");return this.#Wt.set(t,e),this}build(){const t=new Gn(this.#Wt);return this.#Wt.clear(),t}}class Gn{attributeInterpreters;vertexByteSize;#jt;#zt;constructor(t){this.attributeInterpreters=new Map(t);let e=0;const n=new Array(this.attributeInterpreters.size),r=new Map;for(const[t,i]of this.attributeInterpreters)n[0]=e,r.set(t,e),e+=i.byteSize;this.vertexByteSize=e,this.#jt=n,this.#zt=r}getByteOffsetViaIndex(t){if(!Number.isInteger(t))throw new Error("not an integer");if(t<0||t>=this.#jt.length)throw new Error("!?");return this.#jt[t]}getByteOffsetViaAttribute(t){const e=this.#zt.get(t);if(null==e)throw new Error("!?");return e}describe(t){for(const[e,n]of this.attributeInterpreters)e.describeLayout(t,n,this)}}class Hn{gl;#Kt=3;#Gt=8192;#Ht=this.#Kt*this.#Gt;#qt;#Yt;#Xt;#Qt;#Zt;#Jt;#te;#ee;#ne=0;#re=0;#ie;get#se(){return bt(this.#ie.value)}get#oe(){return vt(this.#ie.value)}#ae;constructor(t,e,n){this.gl=t,this.#ie=n,this.#ae=e;const r=(new Kn).add(this.#ae.attributes.worldPosition,jn.Create(3)).add(this.#ae.attributes.vertexNormal,jn.Create(3)).add(this.#ae.attributes.tintColor,zn.Create(4,{normalized:!0})).build();this.#qt=r.vertexByteSize;const i=this.#qt*this.#Ht,s=this.#Ht*qn.int16,o=new ArrayBuffer(i),a=new ArrayBuffer(s);this.#Yt=new DataView(o),this.#Xt=0,this.#Qt=new DataView(a),this.#Zt=0;const c=this.gl.createVertexArray();if(null==c)throw new Error("Expected “vao” to be non-nullish.");this.#Jt=c,this.gl.bindVertexArray(this.#Jt);const u=this.gl.createBuffer();if(null==u)throw new Error("Expected “attributeDataGpuBuffer” to be non-nullish.");this.#te=u,this.gl.bindBuffer(this.gl.ARRAY_BUFFER,u),this.gl.bufferData(this.gl.ARRAY_BUFFER,i,this.gl.STREAM_DRAW),r.describe(t);const l=this.gl.createBuffer();if(null==l)throw new Error("Expected “elementArrayGpuBuffer” to be non-nullish.");this.#ee=l,this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,this.#ee),this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER,s,this.gl.DYNAMIC_DRAW),this.gl.bindVertexArray(null),this.gl.useProgram(this.#ae.glProgram),this.#ce(),this.#ue(),this.gl.clearColor(.2,.2,.23,1),this.gl.enable(this.gl.BLEND),this.gl.blendFunc(this.gl.ONE,this.gl.ONE_MINUS_SRC_ALPHA),this.gl.enable(this.gl.CULL_FACE),this.gl.enable(this.gl.DEPTH_TEST),this.#ie.observe((()=>{this.#ce(),this.#ue()}))}#ce(){const t=Math.PI/10,e=this.#se/this.#oe;this.setProjectionMatrix(function(t,e,n,r){const i=Math.tan(t/2),s=n-r;return new Float32Array([1/(e*i),0,0,0,0,1/i,0,0,0,0,(n+r)/s,-1,0,0,2*n*r/s,0])}(t,e,10,1e4))}#ue(){this.gl.viewport(0,0,this.#se,this.#oe)}canAttributeBufferAccommodate(t){const e=t*this.#qt;return this.#Xt+e<=this.#Yt.byteLength}canElementsBufferAccommodate(t){const e=2*t;return this.#Zt+e<=this.#Qt.byteLength}writeToAttributeBuffer(t,e,n){this.#Yt.setFloat32(this.#Xt,Rt(t),!0),this.#Xt+=qn.float32,this.#Yt.setFloat32(this.#Xt,Ot(t),!0),this.#Xt+=qn.float32,this.#Yt.setFloat32(this.#Xt,Pt(t),!0),this.#Xt+=qn.float32,this.#Yt.setFloat32(this.#Xt,Rt(e),!0),this.#Xt+=qn.float32,this.#Yt.setFloat32(this.#Xt,Ot(e),!0),this.#Xt+=qn.float32,this.#Yt.setFloat32(this.#Xt,Pt(e),!0),this.#Xt+=qn.float32,this.#Yt.setUint32(this.#Xt,n.uint32_rgba,!1),this.#Xt+=qn.uint32}writeToElementsBuffer(t,e){for(const t of e)this.#Qt.setUint16(this.#Zt,this.#ne+t,!0),this.#Zt+=qn.uint16;this.#ne+=t,this.#re+=e.length}setLightDirection(t){this.#ae.uniforms.lightDirection.set(this.gl,t)}setProjectionMatrix(t){this.#ae.uniforms.projectionMatrix.set(this.gl,t)}flush(){0!=this.#ne&&(this.gl.bindVertexArray(this.#Jt),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.#te),this.gl.bufferData(this.gl.ARRAY_BUFFER,this.#Yt,this.gl.DYNAMIC_DRAW,0,this.#Xt),this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,this.#ee),this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER,this.#Qt,this.gl.DYNAMIC_DRAW,0,this.#Zt),this.gl.drawElements(this.gl.TRIANGLES,this.#re,this.gl.UNSIGNED_SHORT,0),this.gl.bindVertexArray(null),this.#re=0,this.#ne=0,this.#Xt=0,this.#Zt=0)}clearColorBufferBit(){this.gl.clear(this.gl.COLOR_BUFFER_BIT)}}const qn={int8:1,uint8:1,int16:2,uint16:2,int32:4,uint32:4,float32:4};class Yn extends R{position=this.Input((()=>Vt(0,0,0)));anchor=this.Input((()=>Vt(0,0,0)));transform=this.Input((()=>ke.Unit));dimensions=this.Input((()=>Vt(1,1,1)));color=this.Input((()=>P.Black));#le;#M=this.Inject(Te);constructor(t){super(t);const e=Vt(-.5,-.5,-.5),n=Vt(-.5,-.5,.5),r=Vt(-.5,.5,-.5),i=Vt(-.5,.5,.5),s=Vt(.5,-.5,-.5),o=Vt(.5,-.5,.5),a=Vt(.5,.5,-.5),c=Vt(.5,.5,.5),u=[n,o,c,i,s,e,r,a,e,n,i,r,o,s,a,c,i,c,a,r,o,n,e,s],l=[Bt,Bt,Bt,Bt,Mt,Mt,Mt,Mt,St,St,St,St,At,At,At,At,Ft,Ft,Ft,Ft,Nt,Nt,Nt,Nt];this.#le=new ke,this.traits.set(this.#M.geometry,u),this.traits.set(this.#M.vertexNormals,l),this.traits.set(this.#M.localTransform,this.#le),this.traits.set(this.#M.geometryElements,Array.from(function*(t,e,n){for(let r=0;r<n;r++){const n=e*r;for(const e of t)yield n+e}}([0,1,2,0,2,3],4,6))),this.traits.set(this.#M.tintColor,P.LightGray)}onUpdate(){(this.position.didChange||this.transform.didChange||this.anchor.didChange||this.dimensions.didChange)&&this.#he(),this.color.didChange&&this.traits.set(this.#M.tintColor,this.color.value)}onDestroy(){}#he(){this.#le.assign(this.transform.value),this.#le.scaleWithin(this.dimensions.value[0],function(t){return t[1]}(this.dimensions.value),function(t){return t[2]}(this.dimensions.value)),this.#le.translateWithin(-Rt(this.anchor.value),-Ot(this.anchor.value),-Pt(this.anchor.value)),this.#le.translate(Rt(this.position.value),Ot(this.position.value),Pt(this.position.value))}}const Xn=new s("@morkite/webgl-components/3d/GROUP_TRAIT_TOKENS");class Qn extends R{position=this.Input((()=>Vt()));transform=this.Input((()=>ke.Unit));children=this.Input();#le;#M=this.Inject(Xn);constructor(t){super(t),this.#le=new ke,this.traits.set(this.#M.localTransform,this.#le)}onUpdate(){if((this.position.didChange||this.transform.didChange)&&this.#he(),this.children.didChange){this.childrenManager.count>0&&this.childrenManager.destroyAt(0);this.childrenManager.createAt(0,this.children.value).update()}}onDestroy(){}#he(){this.#le.assign(this.transform.value),this.#le.translate(Rt(this.position.value),Ot(this.position.value),Pt(this.position.value))}}const Zn=new s("@morkite/webgl-components/3d/PROJECTION_TRAIT_TOKENS"),Jn=new s,tr=new d("FACE_DECORATIONS");class er{debuggingName;world;_transform=O.Create(ke.Unit);transform=this._transform;position=this.transform.map((t=>function(t,e){const[,,,,,,,,,n,r,i]=e;return Wt(t,n,r,i)}(Vt(),t.matrix)));orientation=this.transform.map((t=>we(de(),t.matrix)));right=this.orientation.map((t=>{return Ut(e=Vt(),function(t){return t[0]}(n=t)),_t(e,function(t){return t[1]}(n)),$t(e,function(t){return t[2]}(n)),e;var e,n}));front=this.orientation.map((t=>te(Vt(),t)));up=this.orientation.map((t=>{return Ut(e=Vt(),function(t){return t[6]}(n=t)),_t(e,function(t){return t[7]}(n)),$t(e,function(t){return t[8]}(n)),e;var e,n}));data;constructor(t,e){this.debuggingName=t,this.world=e,this.data=new p}setTransform(t){return this.world.setTransform(this,t),this}applyTransform(t){return this.world.applyTransform(this,t),this}}class nr{create(){}move(t,e){}}class rr{#de=new Set;#pe;constructor(t){this.#pe=t}*tiles(){yield*this.#de}*tilesAt(t){for(const e of this.#de)Qt(e.position.value,t,1e-6)&&(yield e)}create(t,e){const n=new er(t,this);return n.setTransform(e.clone()),this.#de.add(n),this.#pe.create(n,e),n}delete(t){return this.#de.delete(t),this}setTransform(t,e){this.#fe(t);return t._transform.set(e.clone()),this.#pe.move(t,e),this}applyTransform(t,e){this.#fe(t);const n=t,r=n._transform.value.clone().applyTransform(e);return n._transform.set(r),this.#pe.move(t,r),this}#fe(t){if(t.world!=this)throw new Error("This tile doesn't belong to this world.")}}class ir{#me=!1;get performed(){return this.#me}perform(t){if(this.#me)throw new Error("Cannot perform the same action twice.");this.performCrux(t),this.#me=!0}}class sr extends ir{performCrux(t){}}class or extends ir{#ge;constructor(t){super(),this.#ge=t}performCrux(t){for(const e of this.#ge)e.perform(t)}}class ar extends ir{worldTile;transformation;constructor(t,e){super(),this.worldTile=t,this.transformation=e}performCrux(t){t.applyTransform(this.worldTile,this.transformation)}}function*cr(t,e,n){for(let r=t[0]-(e.left??0);r<=t[0]+(e.right??0);r++)yield Vt(r,t[0]-(e.back??0),n),yield Vt(r,t[0]+(e.front??0),n);for(let r=t[0]-(e.back??0)+1;r<=t[0]+(e.front??0)-1;r++)yield Vt(t[0]-(e.left??0),r,n),yield Vt(t[0]+(e.right??0),r,n)}function ur(t,e,n){return Vt(t,e,n)}const lr=ur(1,0,0),hr=ur(-1,0,0),dr=ur(0,1,0),pr=ur(0,-1,0),fr=ur(0,0,1),mr=ur(0,0,-1),gr=new Set([lr,hr,dr,pr,fr,mr]);function wr(t){for(const e of gr)if(Qt(e,t,1e-6))return e;return null}function yr(t){const e=wr(t);if(null==e)throw new Error(`Expected ${function(t){return`(${t[0]}, ${t[1]}, ${t[2]})`}(t)} to be one of the six isometric directions.`);return e}class br extends rt{worldTile=this.Input();#we=this.worldTile.flatMap((t=>t.position));#ye=this.#we.map((t=>{return(Rt(e=t)+Ot(e)+Pt(e))%2?P.DarkGray:P.Gray;var e}));template=ht(Yn).bind("dimensions",[1,1,1]).bind("color",this.#ye)}class vr extends rt{worldTile=this.Input();forklift=this.Inject(Kr);forksColor=this.forklift.isHoldingCrate.map((t=>t?P.Magenta:P.Yellow));forksTransform=this.forklift.forksLifted.map((t=>t?(new ke).translate(0,0,1):ke.Unit));template=ht(Qn).setChildren([ht(Yn).bind("dimensions",[1,1,2]).bind("anchor",[0,0,-.25]).bind("color",P.Red),ht(Qn).bind("transform",this.forksTransform).setChildren([ht(Yn).bind("dimensions",[.3,1,.1]).bind("anchor",[-1,-1,-1]).bind("position",[0,0,-.5]).bind("color",this.forksColor),ht(Yn).bind("dimensions",[.3,1,.1]).bind("anchor",[1,-1,-1]).bind("position",[0,0,-.5]).bind("color",this.forksColor)])])}class Tr extends rt{worldTile=this.Input();template=ht(Yn).bind("dimensions",[.75,.75,.75]).bind("color",P.Cyan)}class kr{data=new p}class xr{faceDecoration;orientation;constructor(t,e){this.faceDecoration=t,this.orientation=e}}class Cr{#o=new Map;set(t,e){const n=wr(te(Vt(),t));if(null==n)throw new Error('This orientation is not supported. Make sure "y" is a unit vector.');if(this.#o.has(n))throw new Error("This face is already decorated.");const r=new xr(e,t);return this.#o.set(n,r),this}get(t){return this.#o.get(t)??null}}const Dr=new d("SOCKET");class Er{_data=new p;data=this._data}const Ir=new d("PLUG");class Ar{_data=new p;data=this._data}const Sr=new d("FORK_PLUG");class Fr extends Ar{constructor(){super(),this._data.set(Sr,null)}}class Nr extends Er{accepts(t){return t.data.has(Sr)}}function Br(t){return t}function Mr(t,e,...n){var r;return function(...t){return t.reduce(((t,e)=>n=>e(t(n))),Br)}(...null==e?[]:null!=(r=e)&&"function"==typeof r[Symbol.iterator]?e:[e,...n])(t)}function Vr(t,...e){return function(n){return t(n,...e)}}function Rr(t){return function*(e){let n=0;for(const r of e)t(r,n++)&&(yield r)}}function Or(t){let e=0;for(const n of t)e++;return e}function Pr(t){for(const e of t)return e}function Lr(t,e){let n=0;for(const r of t)e(r,n++)}const Ur=new d("WORLD_TILE_TYPE");class _r{worldTile;constructor(t){this.worldTile=t,this.worldTile.data.set(Ur,this)}}class $r extends _r{component=br}class Wr extends _r{component=vr}class jr extends _r{component=null}class zr extends _r{component=null;constructor(t){super(t);const e=new Fr,n=new kr;n.data.set(Ir,e);const r=(new Cr).set(Jt,n);t.data.set(tr,r)}}class Kr{butt;head;forks;forksRelativeTransform;forksLifted;forksViableTransform;forksAlternativePosition;#be=O.Create(null);grabbedCrate=this.#be;isHoldingCrate=this.#be.map((t=>null!==t));constructor(t,e,n){this.butt=t,this.head=e,this.forks=n,this.forksRelativeTransform=this.forks.worldTile.transform.with(this.butt.worldTile.transform).map((([t,e])=>t.clone().applyTransform(e.clone().inverse()))),this.forksLifted=this.forksRelativeTransform.map((t=>(console.log(t),It(t.matrix[11],1)))),this.forksViableTransform=this.forksLifted.map((t=>t?(new ke).translate(0,0,-1):(new ke).translate(0,0,1))),this.forksAlternativePosition=this.forksViableTransform.with(this.forks.worldTile.position).map((([t,e])=>ge(Vt(),t.matrix,e)))}toggleForksElevation(){const t=this.forksViableTransform.value;return this.forks.worldTile.applyTransform(t),t}grabCrate(t){this.#be.set(t)}releaseCrate(){this.#be.set(null)}}class Gr extends _r{component=Tr;constructor(t){super(t);const e=new Nr,n=new kr;n.data.set(Dr,e);const r=new Cr;var i;Mr(gr,(i=t=>{const e=Vt(0,0,1),n=qt(Vt(),t,e);return i=t,s=e,Zt(Rt(r=n),Ot(r),Pt(r),Rt(i),Ot(i),Pt(i),Rt(s),Ot(s),Pt(s));var r,i,s},function*(t){let e=0;for(const n of t)yield i(n,e++)}),Vr(Lr,(t=>{r.set(t,n)}))),t.data.set(tr,r)}}class Hr{forklift;crates;world;constructor(){this.world=new rr(new nr);const t=function*(t,e){for(let n=t[0]-(e.left??0);n<=t[0]+(e.right??0);n++)for(let r=t[0]-(e.back??0);r<=t[1]+(e.front??0);r++)for(let i=t[0]-(e.down??0);i<=t[1]+(e.up??0);i++)yield Vt(n,r,i)}(Vt(),{front:6,back:6,left:6,right:6});for(const e of t){const t=(new ke).translateVia(e);new $r(this.world.create("ground",t))}for(const t of[1,2]){const e=cr(Vt(),{front:6,back:6,left:6,right:6},t);for(const t of e){const e=(new ke).translateVia(t);new $r(this.world.create("wall",e))}}const e=new Wr(this.world.create("your butt",(new ke).translate(0,0,1))),n=new jr(this.world.create("your head",(new ke).translate(0,0,2))),r=new zr(this.world.create("your forks",(new ke).translate(0,1,1)));this.forklift=new Kr(e,n,r);const i=new Array,s=[Vt(2,-2,1),Vt(-1,-3,1)];for(let t=0;t<s.length;t++){const e=s[t],n=(new ke).translateVia(e);i.push(new Gr(this.world.create("crate",n)))}this.crates=i}moveForkliftForward(){const t=this.forklift.butt.worldTile.front.value;return this.#ve(t)}moveForkliftBackward(){const t=Lt(this.forklift.butt.worldTile.front.value);return zt(t,t),this.#ve(t)}#ve(t){const e=[this.forklift.butt.worldTile,this.forklift.head.worldTile,this.forklift.forks.worldTile];null!=this.forklift.grabbedCrate.value&&e.push(this.forklift.grabbedCrate.value);const n=[];for(const r of e){const i=Lt(r.position.value);Kt(i,i,t);const s=this.world.tilesAt(i);t:for(const t of s){if(e.includes(t))continue;const i=r.data.get(tr),s=t.data.get(tr);if(null!=i&&null!=s){const e=Gt(Vt(),t.position.value,r.position.value),n=fe(Zt(),r.orientation.value),o=me(Vt(),n,e),a=i.get(yr(o)),c=Gt(Vt(),r.position.value,t.position.value),u=fe(Zt(),t.orientation.value),l=me(Vt(),u,c),h=s.get(yr(l));if(null!=a&&null!=h){console.log("source decor and target decor",a,h);const t=[[a,h],[h,a]];for(const[e,n]of t){const t=e.faceDecoration.data.get(Ir,{onMiss:"null"}),r=n.faceDecoration.data.get(Dr,{onMiss:"null"});if(null!=t&&null!=r){if(r.accepts(t,Jt))continue t}}}}n.push(`${r.debuggingName} would hit ${t.debuggingName}`)}}if(n.length>0)return alert(n.join("\n")),new sr;const r=(new ke).translateVia(t),i=e.map((t=>new ar(t,r)));return new or(i)}rotateForkliftRight(){return this.#Te(-Math.PI/2)}rotateForkliftLeft(){return this.#Te(+Math.PI/2)}#Te(t){const e=[this.forklift.butt.worldTile,this.forklift.head.worldTile,this.forklift.forks.worldTile];null!=this.forklift.grabbedCrate.value&&e.push(this.forklift.grabbedCrate.value);const n=this.forklift.butt.worldTile.position.value,r=(new ke).translateVia(zt(Vt(),n)).rotateAroundZ(t).translateVia(n),i=new Array;for(const r of e){const c=Vt();Gt(c,r.position.value,n);const u=Rt(c),l=Ot(c);if(It(u,0)&&It(l,0))continue;const h=yt(u,l),d=Math.max(Math.abs(u),Math.abs(l)),p=Dt(yt(),h,yt(d,0)),f=Dt(yt(),h,yt(0,d));console.log("projection vectors",p,f);const m=[p,f].sort(((t,e)=>xt(t)>xt(e)?-1:1)),[g]=m,w=Ct(yt(),g,t);Tt(w,Et(bt(w)),Et(vt(w)));const y=Ct(yt(),w,t);Tt(y,Et(bt(y)),Et(vt(y)));const b=Math.cos(t),v=Math.sin(t),T=ye(-1,0,0,-1),k=ye(b,v,-v,b);be(k,T,k),o=k,a=T,(s=k)[0]=o[0]+a[0],s[1]=o[1]+a[1],s[2]=o[2]+a[2],s[3]=o[3]+a[3];const x=Et(kt(ve(yt(),k,w),h),1e-6),C=Et(2*d+1-1-x),D=Vt(bt(w),vt(w),0),E=Vt(bt(y),vt(y),0),I=Lt(r.position.value);for(let t=0;t<x;t++){const t=Mr(this.world.tilesAt(I),Rr((t=>!e.includes(t))),Vr(Pr));if(null!=t){i.push(`${r.debuggingName} would hit ${t.debuggingName}`);break}Kt(I,I,D)}if(0==i.length)for(let t=0;t<C+1;t++){const t=Mr(this.world.tilesAt(I),Rr((t=>!e.includes(t))),Vr(Pr));if(null!=t){i.push(`${r.debuggingName} would hit ${t.debuggingName}`);break}Kt(I,I,E)}}var s,o,a;return i.length>0?(alert(i.join("\n")),new sr):new or(e.map((t=>new ar(t,r))))}toggleForkliftForkState(){const t=this.forklift.forks.worldTile.position.value;if(null==this.forklift.grabbedCrate.value){const e=Array.from(this.world.tilesAt(t)).filter((t=>t!=this.forklift.forks.worldTile));if(0==e.length)return alert("Nothing to grab."),new sr;if(e.length>1)return alert("Too many tiles at forks. This is a bug in the game."),new sr;const[n]=e;this.forklift.grabCrate(n)}else this.forklift.releaseCrate();return new or([])}toggleForkliftForkElevation(){if(null==this.forklift.grabbedCrate.value){if(Mr(this.world.tilesAt(this.forklift.forks.worldTile.position.value),Rr((t=>t!=this.forklift.forks.worldTile)),Vr(Or))>0)return alert("can't lift forks because they are locked in. either move back or grab."),new sr}if(Mr(this.world.tilesAt(this.forklift.forksAlternativePosition.value),Vr(Or))>0)return alert("your forks can't move there."),null==this.forklift.grabbedCrate.value||this.forklift.forksLifted.value||alert("i think you're trying to lift stacked crates? you'll have to wait for next release! thanks for playing!"),new sr;const t=this.forklift.toggleForksElevation();return null!=this.forklift.grabbedCrate.value&&this.forklift.grabbedCrate.value.applyTransform(t),new or([])}}class qr extends rt{worldTile=this.Input();component=this.worldTile.map((t=>t.data.get(Ur,{onMiss:"null"})?.component??null));#ke=this.worldTile.flatMap((t=>t.transform));template=ht(Qn).bind("transform",this.#ke).setChildren([ht(pt).bind("condition",this.component.map((t=>t===br))).setChildren([ht(br).bind("worldTile",this.worldTile)]),ht(pt).bind("condition",this.component.map((t=>t===Tr))).setChildren([ht(Tr).bind("worldTile",this.worldTile)]),ht(pt).bind("condition",this.component.map((t=>t===vr))).setChildren([ht(vr).bind("worldTile",this.worldTile)])])}class Yr{#xe=new Map;add(t,e){const n=this,r={token:t,trigger(t){e(t)},cancel(){n.#Ce(t,r)}};let i=this.#xe.get(t);return null==i&&(i=new Set,this.#xe.set(t,i)),i.add(r),r}triggerSubscriptions(t,e){const n=this.#xe.get(t);if(null!=n)for(const t of n)t.trigger(e)}#Ce(t,e){const n=this.#xe.get(t);null!=n&&(n.delete(e),0==n.size&&this.#xe.delete(t))}}class Xr{#De=new Yr;broadcast(t,e){this.#De.triggerSubscriptions(t,e)}subscribe(t,e){return this.#De.add(t,e)}}const Qr=["KeyW","KeyA","KeyS","KeyD","KeyQ","KeyE","KeyF","KeyZ","KeyX","KeyC","Escape","AltLeft","ControlLeft"],Zr=new d("@morkite/input-methods/keyboard/KEY_DOWN");class Jr{#Ee;constructor(t){this.#Ee=t??new Xr,document.addEventListener("keydown",(t=>{Qr.includes(t.code)&&this.#Ee.broadcast(Zr,t.code)}))}onKeyDown(t,e){return this.#Ee.subscribe(Zr,(n=>{n===t&&e(n)}))}}var ti,ei,ni;!function(t){t[t.Linear=9729]="Linear",t[t.Nearest=9728]="Nearest"}(ti||(ti={})),function(t){t[t.Linear=9729]="Linear",t[t.Nearest=9728]="Nearest",t[t.NearestMipmapNearest=9984]="NearestMipmapNearest",t[t.LinearMipmapNearest=9985]="LinearMipmapNearest",t[t.NearestMipmapLinear=9986]="NearestMipmapLinear",t[t.LinearMipmapLinear=9987]="LinearMipmapLinear"}(ei||(ei={})),function(t){t[t.Repeat=10497]="Repeat",t[t.ClampToEdge=33071]="ClampToEdge",t[t.MirroredRepeat=33648]="MirroredRepeat"}(ni||(ni={}));class ri{static Default=new ri;magnificationFilter;minificationFilter;textureWrapping;constructor(t){this.magnificationFilter=t?.magnificationFilter??ti.Linear,this.minificationFilter=t?.minificationFilter??ei.NearestMipmapLinear,this.textureWrapping=null==t?.textureWrapping?{s:ni.Repeat,t:ni.Repeat}:"number"==typeof t.textureWrapping?{s:t.textureWrapping,t:t.textureWrapping}:{s:t.textureWrapping.s,t:t.textureWrapping.t}}}class ii{#Ie=[];add(t){"full"==t.type&&this.clear(),this.#Ie.push(t)}*[Symbol.iterator](){yield*this.#Ie}clear(){this.#Ie.splice(0,this.#Ie.length)}}class si{name;parameters;static TransparentPixel=new si("transparent pixel",1,1);static WhitePixel=new si("white pixel",1,1);static{this.TransparentPixel.queueFullUpload(new Uint8ClampedArray([0,0,0,0])),this.WhitePixel.queueFullUpload(new Uint8ClampedArray([255,255,255,255]))}dimensions;#Ae=1;get version(){return this.#Ae}constructor(t,e,n,r=ri.Default){this.name=t,this.parameters=r,this.dimensions=yt(e,n)}#Ie=new ii;queueFullUpload(t){const e={type:"full",data:t};this.#Ie.add(e),this.bumpVersion()}queuePartialUpload(t,e){const n={type:"partial",region:t,data:e};this.#Ie.add(n),this.bumpVersion()}flush(){const t=Array.from(this.#Ie);return this.#Ie.clear(),t}bumpVersion(){this.#Ae++}}class oi{texture;static TransparentPixel=new oi(si.TransparentPixel);rectangle;normalizedRectangle;constructor(t,e){this.texture=t;const n=ee(this.texture.dimensions),r=ne(this.texture.dimensions);this.rectangle=e??ae(0,0,n,r),this.normalizedRectangle=function(t,e,n){const r=re(e)/ee(n),i=ie(e)/ne(n),s=se(e)/ee(n),o=oe(e)/ne(n);return function(t,e,n,r,i){return t[0]=e,t[1]=n,t[2]=r,t[3]=i,t}(t,r,i,s,o)}(ae(),this.rectangle,this.texture.dimensions)}}class ai{texture;glTexture;unit;mostRecentlyUploadedVersion;constructor(t,e,n,r=-1){this.texture=t,this.glTexture=e,this.unit=n,this.mostRecentlyUploadedVersion=r}}class ci{gl;textures=new Map;currentlyActiveUnit=0;constructor(t){this.gl=t}create(t){if(this._hasTexture(t))throw new Error("already created");const e=this.gl.createTexture();if(null==e)throw new Error("Expected glTexture to be non-null.");const n=new ai(t,e,null);this.textures.set(t,n)}bindTo(t,e){const n=this._getDetailsByTexture(t);if(null==n)throw new Error("Expected details to be non-null.");if(n.unit==e)return;const r=this._getDetailsByUnit(e);null!=r&&(r.unit=null),this._updateCurrentlyActiveUnit(e),this.gl.bindTexture(this.gl.TEXTURE_2D,n.glTexture),n.unit=e}upload(t,e){let n=this._getDetailsByTexture(e);if(null==n&&(this.create(e),n=this._getDetailsByTexture(e),null==n))throw new Error("errrm");if(this.bindTo(e,t),e.version==n.mostRecentlyUploadedVersion)return;this._updateCurrentlyActiveUnit(t),this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,e.parameters.magnificationFilter),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,e.parameters.minificationFilter),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,e.parameters.textureWrapping.s),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,e.parameters.textureWrapping.t);const r=e.flush();if(0==r.length)throw new Error(`Tried to use a texture with no data in it: ${e.name}.`);-1==n.mostRecentlyUploadedVersion&&"partial"==r[0].type&&this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,ee(e.dimensions),ne(e.dimensions),0,this.gl.RGBA,this.gl.UNSIGNED_BYTE,null);for(const t of r)switch(t.type){case"partial":this.gl.texSubImage2D(this.gl.TEXTURE_2D,0,re(t.region),ie(t.region),se(t.region),oe(t.region),this.gl.RGBA,this.gl.UNSIGNED_BYTE,t.data);break;case"full":this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,ee(e.dimensions),ne(e.dimensions),0,this.gl.RGBA,this.gl.UNSIGNED_BYTE,t.data)}n.mostRecentlyUploadedVersion=e.version}delete(t){const e=this._getDetailsByTexture(t);if(null==e)throw new Error("Expected details to be non-null.");this.gl.deleteTexture(e.glTexture),this.textures.delete(t)}_updateCurrentlyActiveUnit(t){this.currentlyActiveUnit!=t&&(this.gl.activeTexture(this.gl.TEXTURE0+t),this.currentlyActiveUnit=t)}_hasTexture(t){return this.textures.has(t)}_getDetailsByTexture(t){return this.textures.get(t)??null}_getDetailsByUnit(t){for(const e of this.textures.values())if(e.unit==t)return e;return null}}class ui{unit;constructor(t){this.unit=t}texture=null;locked=!1}class li{count;slots;constructor(t){this.count=t;const e=new Array(this.count);for(let n=0;n<t;n++)e[n]=new ui(n);this.slots=e}getFirstFreeSlot(){for(const t of this.slots)if(null==t.texture)return t;return null}getByTexture(t){for(const e of this.slots)if(e.texture==t)return e;return null}getBySlotId(t){if(!Number.isInteger(t)||t<0||t>=this.count)throw new Error(`Not a valid ID: ${t}.`);return this.slots[t]}unlockAll(){for(const t of this.slots)t.locked=!1}getTextureSlots(){const t=new Map;for(const{unit:e,texture:n}of this.slots)null!=n&&t.set(n,e);return t}}class hi{capacity;evictionStrategy;slots;constructor(t,e){this.capacity=t,this.evictionStrategy=e,this.slots=new li(t)}decideOnUnit(t){let e=this.slots.getByTexture(t);if(null==e){const t=this.slots.getFirstFreeSlot();if(null!=t)e=t;else{let t=!1;const n=this.evictionStrategy.judge();for(const r of n){const n=this.slots.getByTexture(r);if(null==n)throw new Error("Oops!");if(!n.locked){t=!0,e=n;break}}if(!t)return null}}return e.unit}lockInto(t,e){const n=this.slots.getBySlotId(t);null!=n.texture&&n.texture!=e&&this.evictionStrategy.forget(n.texture),n.texture=e,n.locked=!0,this.evictionStrategy.markUsage(e)}unlockAll(){this.slots.unlockAll()}}class di{}class pi extends di{usageOrder=[];markUsage(t){const e=this.usageOrder.indexOf(t);e>-1&&this.usageOrder.splice(e,1),this.usageOrder.push(t)}forget(t){const e=this.usageOrder.indexOf(t);e>-1&&this.usageOrder.splice(e,1)}*judge(){yield*this.usageOrder}}class fi{glContextTexturesManager;activeTexturesManager;#M;constructor(t){this.#M=t;const e=new pi;this.activeTexturesManager=new hi(8,e)}onProcessorCreated(t){this.glContextTexturesManager=new ci(t.gl)}onFrameStart(){}process(t){const e=t.get(this.#M.requiredTexture);if(null==e)return new W;const n=this.activeTexturesManager.decideOnUnit(e);return null==n?new gi(this):new mi(this,t,e,n,this.#M)}createBreakCommand(){return new gi(this)}onFrameFinish(){}}class mi extends ${processor;nugget;texture;unit;traitTokens;constructor(t,e,n,r,i){super(!1),this.processor=t,this.nugget=e,this.texture=n,this.unit=r,this.traitTokens=i}execute(){this.nugget.set(this.traitTokens.textureUnit,this.unit),this.processor.activeTexturesManager.lockInto(this.unit,this.texture),this.processor.glContextTexturesManager.upload(this.unit,this.texture)}}class gi extends ${processor;constructor(t){super(!0),this.processor=t}execute(){this.processor.activeTexturesManager.unlockAll()}}function wi(t){const{width:e,height:n}=function(t){const e=getComputedStyle(t),n=parseFloat(e.paddingLeft)+parseFloat(e.paddingRight),r=parseFloat(e.paddingTop)+parseFloat(e.paddingBottom);return{width:t.clientWidth-n,height:t.clientHeight-r}}(t),r=new v([e,n]),i=new ResizeObserver((t=>{for(const e of t){const{width:t,height:n}=e.contentRect;r.set([t,n])}}));return i.observe(t),r}const yi=new s("TRAIT_TOKENS");function bi(t,e,n,r){const i=Vt(Math.cos(r)*Math.sin(n),Math.cos(r)*Math.cos(n),Math.sin(r));return Yt(i,e,i),Kt(i,t,i),function(t,e,n){const r=Vt();Gt(r,e,t),Xt(r,r);const i=Vt();qt(i,n,r),Xt(i,i);const s=Vt();qt(s,r,i);const o=-Ht(i,e),a=-Ht(s,e),c=-Ht(r,e),u=ce(Rt(i),Rt(s),Rt(r),Ot(i),Ot(s),Ot(r),Pt(i),Pt(s),Pt(r),o,a,c);return ke.FromMatrix(u)}(t,i,Vt(0,0,1))}function vi(t,e,n,r,i){return(i-t)*(r-n)/(e-t)+n}class Ti{#Se;get tileDimensionsPx(){return this.#Se.tileDimensionsPx}constructor(t){this.#Se=t}getProjection(t,e){const[n,r,i]=t,[s,o,a]=e,c=this.#Se.tileDimensionsPx;return yt(c/2*(n*s-r*o),-c/4*(n*s+r*o)+c/2*i*a)}}Error.stackTraceLimit=1/0,document.body.style.margin="0",document.body.style.width="100dvw",document.body.style.height="100dvh",function(){const t=document.createElement("meta");t.name="viewport",t.content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no",document.head.appendChild(t);const e=document.createElement("style");e.textContent="\n    html, body {\n      margin: 0;\n      padding: 0;\n      overflow: hidden;\n      touch-action: none;\n      user-select: none;\n      -webkit-user-select: none;\n      -webkit-touch-callout: none;\n      -webkit-tap-highlight-color: transparent;\n    }\n  ",document.head.appendChild(e);const n=t=>t.preventDefault();document.addEventListener("contextmenu",n),document.addEventListener("gesturestart",n),document.addEventListener("gesturechange",n),document.addEventListener("gestureend",n)}();const ki=document.createElement("button");ki.dataset.keyboard="KeyW",ki.textContent="⬆";const xi=document.createElement("button");xi.dataset.keyboard="KeyS",xi.textContent="⬇";const Ci=document.createElement("button");Ci.dataset.keyboard="KeyA",Ci.textContent="⬅";const Di=document.createElement("button");Di.dataset.keyboard="KeyD",Di.textContent="➡";const Ei=document.createElement("button");Ei.dataset.keyboard="KeyE",Ei.textContent="⏯";const Ii=document.createElement("button");Ii.dataset.keyboard="KeyQ",Ii.textContent="🔃";const Ai=[ki,xi,Ci,Di,Ei,Ii];for(const t of Ai)t.addEventListener("click",(()=>{const e=t.dataset.keyboard,n=new KeyboardEvent("keydown",{code:e});console.log("dispatching",e,n),document.dispatchEvent(n)}));const Si=document.createElement("div");Si.id="controls-container",Si.append(...Ai),document.body.append(Si),Si.addEventListener("click",(t=>{t.stopPropagation()})),Si.addEventListener("mousemove",(t=>{t.stopPropagation()}));const Fi=document.createElement("style");Fi.textContent='\n    * {\n      box-sizing: border-box;\n      font: inherit;\n    }\n\n    #controls-container {\n      position: absolute;\n      bottom: 0;\n      right: 0;\n      padding: 1rem;\n      display: grid;\n      gap: 1rem;\n      grid-template-columns: 1fr 1fr;\n      grid-template-rows: 1fr 1fr 1fr 1fr;\n      grid-template-areas:\n        "Q E"\n        "W W"\n        "A D"\n        "S S"\n      ;\n      font-size: 1.5rem;\n      \n      & button[data-keyboard="KeyQ"] {\n        grid-area: Q;\n      }\n      \n      & button[data-keyboard="KeyW"] {\n        grid-area: W;\n      }\n      \n      & button[data-keyboard="KeyE"] {\n        grid-area: E;\n      }\n      \n      & button[data-keyboard="KeyA"] {\n        grid-area: A;\n      }\n      \n      & button[data-keyboard="KeyS"] {\n        grid-area: S;\n      }\n      \n      & button[data-keyboard="KeyD"] {\n        grid-area: D;\n      }\n    }\n  ',document.head.appendChild(Fi);new class{#Fe;#Ne;#Be=null;#ie;#Me;#Ve;#Re;#D;constructor(t){this.#Ne=t.sceneRoot;const n=document.createElement("canvas");n.style.display="block",n.style.touchAction="none",this.#ie=wi(t.htmlRoot),this.#ie.observe((({value:[t,e]})=>{n.width=t,n.height=e}));t.htmlRoot.append(n);const r=n.getContext("webgl2");if(null==r)throw new Error("Expected “gl” to be non-nullish.");const i=new _n(r),s=new Hn(r,i,this.#ie),o={debuggingName:new d("traitTokens/debuggingName"),childrenAccessor:new d("traitTokens/childrenAccessor"),undo:new d("traitTokens/undo"),localTransform:new d("traitTokens/localTransform"),worldTransform:new d("traitTokens/worldTransform"),geometry:new d("traitTokens/geometry"),geometryElements:new d("traitTokens/geometryElements"),requiredTexture:new d("traitTokens/requiredTexture"),textureUnit:new d("traitTokens/textureUnit"),texturePosition:new d("traitTokens/texturePosition"),tintColor:new d("traitTokens/tintColor"),projection:new d("traitTokens/projection"),vertexNormals:new d("traitTokens/normals"),directionalLight:new d("traitTokens/directionalLight")},a={worldTransform:new d("frameStorageTokens/worldTransform")},l=new H([new q({debuggingName:o.debuggingName}),new Ee,new Se({directionalLight:o.directionalLight}),new Ae({projection:o.projection}),new nt({debuggingName:o.debuggingName,undo:o.undo,childrenAccessor:o.childrenAccessor},{undoEligibilityTraits:[o.localTransform,o.geometry]}),new Ie({undo:o.undo,localTransform:o.localTransform,worldTransform:o.worldTransform},{worldTransform:a.worldTransform}),new fi({requiredTexture:o.requiredTexture,textureUnit:o.textureUnit}),new xe({geometry:o.geometry,geometryElements:o.geometryElements,tintColor:o.tintColor,vertexNormals:o.vertexNormals},{worldTransform:a.worldTransform}),new X]),h=new G(s,l),p=new Z,f=new et(p),m=new A,g=new M([new B,new st]),w=new Xr,y=new Jr(w),b=new c;if(b.provide(e(Q,p)),b.provide(e(J,f)),b.provide(e(A,m)),b.provide(e(F,g)),b.provide(e(Xr,w)),b.provide(e(Jr,y)),b.provide(e(yi,o)),b.provide(e(u,{debuggingName:o.debuggingName,childrenAccessor:o.childrenAccessor})),b.provide(e(Xn,{localTransform:o.localTransform})),b.provide(e(Zn,{projection:o.projection})),b.provide(e(wt,{tintColor:o.tintColor,geometry:o.geometry,geometryElements:o.geometryElements})),b.provide(e(Te,{geometry:o.geometry,geometryElements:o.geometryElements,tintColor:o.tintColor,localTransform:o.localTransform,vertexNormals:o.vertexNormals})),b.provide(e(Jn,o)),null!=t.providers)for(const e of t.providers)b.provide(e);this.#Fe=b,this.#Me=h,this.#Ve=m,this.#Re=f,this.#D=g}start(){const t=this.#D.instantiateOrThrow(this.#Ne,this.#Fe);this.#Be=t,t.activate({depth:0}),this.#Ve.markAsDirty(t);const e=this.#Re.subscribe((()=>{Promise.resolve().then((()=>{let e=1e4;for(const t of this.#Ve.iterate())if(t.update(),e--<0)throw new Error(`(Don't) hang in there, man. The culprit seems to be ${t.constructor.name}.`);this.#Me.renderFrame(t.traits)})).catch((t=>{console.error("Rendering a frame crashed. Not rendering any more to avoid cluttering the output."),console.error(t),e.unsubscribe()}))}))}destroy(){throw this.#Be?.destroy(),new Error("Not implemented.")}}({htmlRoot:document.body,sceneRoot:class extends rt{#Oe=new Hr;#Pe=O.Create([]);#Le=function(){const t=O.Create(yt(0,0));return document.addEventListener("mousemove",(function(e){t.set(yt(e.clientX,e.clientY))})),t}(this.injector);#Ue=O.Create(Vt(0,0,0));#_e=this.#Le.map((([t])=>vi(0,window.innerWidth,-Math.PI,Math.PI,t)));#$e=this.#Le.map((([,t])=>vi(0,window.innerHeight,Math.PI/2-Math.PI/12,Math.PI/12,t)));#We=this.#Ue.with(this.#_e,this.#$e).map((([t,e,n])=>bi(t,5e4/window.innerWidth,e,n)));#je(){const t=Array.from(this.#Oe.world.tiles());this.#Pe.set(t)}constructor(t){super(t),this.traits.set(this.Inject(yi).directionalLight,Vt(2,-5,-3));const e=this.injector.resolve(Jr);e.onKeyDown("KeyW",(()=>{this.#Oe.moveForkliftForward().perform(this.#Oe.world),this.#je()})),e.onKeyDown("KeyS",(()=>{this.#Oe.moveForkliftBackward().perform(this.#Oe.world),this.#je()})),e.onKeyDown("KeyA",(()=>{this.#Oe.rotateForkliftLeft().perform(this.#Oe.world),this.#je()})),e.onKeyDown("KeyD",(()=>{this.#Oe.rotateForkliftRight().perform(this.#Oe.world),this.#je()})),e.onKeyDown("KeyE",(()=>{this.#Oe.toggleForkliftForkState().perform(this.#Oe.world),this.#je()})),e.onKeyDown("KeyQ",(()=>{this.#Oe.toggleForkliftForkElevation().perform(this.#Oe.world),this.#je()})),this.#je()}template=ht(gt).bind("providers",[e(Kr,this.#Oe.forklift)]).setChildren([ht(Qn).bind("transform",this.#We).setChildren([ht(mt).bind("items",this.#Pe).bind("itemComponent",lt({item:ct(),index:ct()},(({item:t})=>ht(qr).bind("worldTile",t))))])])},providers:[e(Ti,new Ti({tileDimensionsPx:32}))]}).start();
//# sourceMappingURL=main.js.map
