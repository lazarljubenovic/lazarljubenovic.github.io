const t=Symbol("This symbol ensures type safety. If you're seeing this in an error, it means you haven't used ValueProvider, ClassProvider, ProxyProvider or FactoryProvider from @morkite/injectus for creating a Provider.");function e(e,n){return{[t]:!0,type:"value-provider",token:e,value:n}}function n(e){switch(e.type){case"value-provider":return{[t]:!0,type:"factory-provider",token:e.token,factory:()=>e.value};case"class-provider":return{[t]:!0,type:"factory-provider",token:e.token,factory:t=>new e.classConstructor(t)};case"proxy-provider":return{[t]:!0,type:"factory-provider",token:e.token,factory:t=>t.resolve(e.token)};case"factory-provider":return e}}class r{resolved;successful=!0;constructor(t){this.resolved=t}}class i{context;successful=!1;constructor(t){this.context=t}}class s{#t;constructor(t){this.#t=t??"?"}toString(){return`[InjectusToken ${this.#t}]`}}function o(t){return t instanceof s?t.toString():`[ConstructorToken ${t.name}]`}class a extends Error{constructor(t){super();const e=new Array;for(;"request"!=t.type;)"dependency"==t.type&&e.push(t.goal),t=t.master;e.push(t.goal),this.message=`Could not resolve ${e.map(o).join(" <- ")}.`}}class c{#e=null;#n=new Map;#r=new Map;#i=null;constructor(t){this.#e=t??null}provide(...t){for(const e of t){if(this.#n.has(e.token))throw new Error(`Token ${o(e.token)} already provided.`);const t=n(e);this.#n.set(t.token,t)}}resolve(t,{fallback:e=null}={}){this.#i=null!=this.#i?{type:"dependency",master:this.#i,goal:t}:function(t,e){return{type:"request",container:t,goal:e}}(this,t);const n=this.#s(t);if(1==n.successful)return n.resolved;let r=n.context;for(;"request"!=r.type;){if("dependency"==r.type)throw new a(n.context);r=r.master}if(null!=e)return e();throw new a(n.context)}#s(t){if(null==this.#i)throw new Error(`Cannot start resolution without context. Tried resolving ${o(t)}.`);if(this.#r.has(t)){const e=this.#r.get(t);return this.#i=null,new r(e)}const e=this.#n.get(t)??null;if(null!=e){const n=e.factory(this);return this.#r.set(t,n),this.#i=null,new r(n)}if(null!=this.#e){const e=(n=this.#i,s=this.#e,{type:"next-container",master:n,container:s}),r=this.#e;return console.assert(null==r.#i),r.#i=e,this.#i=null,r.#s(t)}var n,s;const a=this.#i;return this.#i=null,new i(a)}}const u=new s("@morkite/component/COMPONENT_TRAIT_TOKENS");class l extends Error{map;key;constructor(t,e){super(),this.map=t,this.key=e}get message(){return`Looking up “${this.key}” yielded no results.`}}class h extends Error{map;key;value;constructor(t,e,n){super(),this.map=t,this.key=e,this.value=n}get message(){return`Conflict while trying to set ${this.key} to “${this.value}”; already set to “${this.map.get(this.key)}”.`}}class p{#t;constructor(t){this.#t=t}toString(){return`Token(${this.#t})`}}class d{#o=new Map;has(t){return this.#o.has(t)}get(t,{onMiss:e="null"}={}){if(!this.has(t))switch(e){case"null":return null;case"throw":throw new l(this,t)}return this.#o.get(t)}getMany(t,{onMiss:e="null"}={}){switch(e){case"null":return t.map((t=>this.#o.has(t)?this.#o.get(t):null));case"throw":{const e=new Array;for(const n of t){if(!this.#o.has(n))throw new l(this,n);e.push(this.#o.get(n))}return e}}}set(t,e,{onConflict:n="overwrite"}={}){if(this.has(t))switch(n){case"overwrite":break;case"ignore":return this;case"throw":throw new h(this,t,e)}return this.#o.set(t,e),this}delete(t,{onMiss:e="ignore"}={}){if(!this.has(t))switch(e){case"ignore":return;case"throw":throw new l(this,t)}this.#o.delete(t)}clear(){this.#o.clear()}}const f=Symbol("@morkite/inspectable/OBSERVABLE");function m(t){return null!=t&&"object"==typeof t&&f in t&&!0===t[f]}class g{#a;#c=new Set;constructor(t){this.#a=t}add(t){const e=this,n={provoke(){t(e.#a)},conclude(){e.#c.delete(n)}};return this.#c.add(n),n}provoke(){for(const t of this.#c)t.provoke()}destroy(){this.#c.clear()}}class w{static Create(t,e){return new w(t,e)}[f]=!0;#u;#l;#h;#p=new Set;#d=new Set;constructor(t,e){this.#u=t,this.#l=e,this.#h=new Array(this.#u.length);for(let t=0;t<this.#u.length;t++){const e=this.#u[t].observe((()=>{this.#p.add(t),this.#f.provoke()}));this.#d.add(e),this.#p.add(t)}}#m=null;get value(){if(this.#p.size>0){for(const t of this.#p)this.#h[t]=this.#u[t].value;this.#p.clear(),this.#m=this.#l(...this.#h)}return this.#m}#f=new g(this);observe(t){return this.#f.add(t)}map(t){return w.Create([this],t)}flatMap(t){return b(w.Create([this],t))}with(...t){return w.Create([this,...t],((...t)=>t))}}const y=Symbol("UNSET");function b(t){const e=new T(y);let n;return t.observe((({value:t})=>{e.set(t.value),n?.conclude(),n=t.observe((({value:t})=>{e.set(t)}))})),w.Create([e],(t=>{if(t==y)throw new Error("Value not yet set.");return t}))}class T{[f]=!0;#m;constructor(t){this.#m=t}get value(){return this.#g(),this.#m}#f=new g(this);observe(t){return this.#g(),this.#f.add(t)}set(t){this.#g(),this.#m=t,this.#f.provoke()}provokeManually(){this.#f.provoke()}#w=!1;#g(){if(this.#w)throw new Error("Cannot operate on a destroyed observable.")}destroy(){this.#f.destroy()}map(t){return w.Create([this],t)}flatMap(t){return b(w.Create([this],t))}with(...t){return w.Create([this,...t],((...t)=>t))}}const v=Symbol("@morkite/core/INPUT");function x(t){return null!=t&&"object"==typeof t&&v in t&&!0===t[v]}class k{[v]=!0;[f]=!0;#y;constructor(t){this.#y=t}#b=!1;#T=!1;#m=null;#v=!1;get didChange(){return this.#v}get value(){if(null!=this.#x)this.#x.needsPull&&(this.#m=this.#x.source.value,this.#x.needsPull=!1);else if(!this.#T&&!this.#b){if(null==this.#y)throw new Error("Value not set.");this.#m=this.#y(),this.#b=!0}return this.#m}#f=new g(this);observe(t){return this.#f.add(t)}set(t){if(this.#g(),null!=this.#x)throw new Error("Cannot set a value manually while an observable is linked.");this.#m=t,this.#v=!0,this.#T=!0}#x=null;link(t){if(this.#g(),null!=this.#x)throw new Error("cannot relink yet");const e=()=>{if(null==this.#x)throw new Error("Expected “this.#activeLink” to be non-nullish.");this.#x.needsPull=!0,this.#v=!0,this.#f.provoke()},n=t.observe(e);this.#x={needsPull:!0,source:t,observance:n},e()}ratify(){this.#v=!1}#w=!1;#g(){if(this.#w)throw new Error("Cannot operate on an input of a destroyed component.")}destroy(){this.#g(),this.#f.destroy(),this.#x?.observance.conclude(),this.#x=null,this.#w=!0}map(t){return w.Create([this],t)}flatMap(t){return b(w.Create([this],t))}with(...t){return w.Create([this,...t],((...t)=>t))}}const C=Symbol("OUTPUT"),D=Symbol("OUTPUT_TYPE");class E{[C]=!0;[D]=void 0;#k=new Set;subscribe(t){const e={onEmit:t,unsubscribe:()=>this.#k.delete(e)};return this.#k.add(e),e}emit(t){for(const e of this.#k)e.onEmit(t)}destroy(){throw new Error("Not implemented.")}}class I{#C;#D;#E=new Array;constructor(t,e){this.#C=t,this.#D=e}get count(){return this.#E.length}at(t){if(!Number.isInteger(t))throw new TypeError(`Index must be an integer, but ${t} was given.`);if(t<0||t>=this.count)throw new RangeError(`Index must be between 0 (inclusive) and ${this.count} (exclusive), but ${t} was given.`);return this.#E[t]}createAt(t,e){if(!this.#C.activated)throw new Error("Cannot spawn a child for an unactivated component. Are you trying to build the tree in the constructor? Use the “onUpdate” hook instead.");if(!Number.isInteger(t))throw new TypeError(`Index must be an integer, but ${t} was given.`);if(t<0||t>this.count)throw new RangeError(`Index must be between 0 (inclusive) and ${this.count} (inclusive), but ${t} was given.`);const n=new c(this.#C.injector),r=this.#D.instantiateOrThrow(e,n);return r.acceptParent(this.#C),r.activate({depth:this.#C.depth+1}),this.#E.splice(t,0,r),r}destroyAt(t){const e=this.ejectAt(t);this.destroyEjected(e)}ejectAt(t){if(!Number.isInteger(t))throw new TypeError(`Index must be an integer, but ${t} was given.`);if(t<0||t>=this.count)throw new RangeError(`Index must be between 0 (inclusive) and ${this.count} (exclusive), but ${t} was given.`);const[e]=this.#E.splice(t,1);return e}reinsertAt(t,e){if(this.#E.includes(e))throw new Error("not ejected or already re-inserted");if(e.parent!=this.#C)throw new Error("not ejected from here");if(!Number.isInteger(t))throw new TypeError(`Index must be an integer, but ${t} was given.`);if(t<0||t>this.#E.length)throw new RangeError(`Index must be between 0 (inclusive) and ${this.count} (inclusive), but ${t} was given.`);this.#E.splice(t,0,e)}destroyEjected(t){if(this.#E.includes(t))throw new Error("not ejected or already re-inserted");if(t.parent!=this.#C)throw new Error("not ejected from here");t.destroy()}createAccessor(){const t=this.#E;return{get count(){return t.length},*iterate(){for(let e=t.length-1;e>=0;e--)yield t[e].traits}}}}class S{#I=new A;markAsDirty(t){this.#I.add(t)}markAsPristine(t){this.#I.remove(t)}iterate(){return this.#I.createIterator()}}class A{#S=0;#A=new Array;createIterator(){return{next:()=>{for(const t of this.#A)if(t.size>0){const[e]=t;return{value:e,done:!1}}return{value:null,done:!0}},[Symbol.iterator](){return this}}}add(t){for(let e=this.#A.length;e<=t.depth;e++){const t=new Set;this.#A.push(t)}const e=this.#A[t.depth];e.has(t)||(e.add(t),this.#S++)}remove(t){if(t.depth>=this.#A.length)return;const e=this.#A[t.depth];e.has(t)&&(e.delete(t),this.#S--)}clear(){for(const t of this.#A)t.clear();this.#S=0}has(t){return this.#A[t.depth].has(t)}get count(){return this.#S}get isEmpty(){return 0==this.#S}get isNotEmpty(){return this.#S>0}}class N{instantiateOrThrow(t,e){const n=this.instantiate(t,e);if(null==n)throw new Error("Could not instantiate this component. Make sure you've provided an appropriate component instantiator which can handle this type of component definitions.");return n}}const F=Symbol("@morkite/core/CLASS_CONSTRUCTOR_COMPONENT_INSTANTIATOR");class B extends N{instantiate(t,e){return F in t?new t(e):null}}class V extends N{#N;constructor(t){super(),this.#N=Array.from(t)}instantiate(t,e){for(const n of this.#N){const r=n.instantiate(t,e);if(null!=r)return r}return null}}let M=1001;class R{static[F]=!0;id=M++;injector;traits;#F;#d=new Set;#B=null;#V;get depth(){if(!this.#M)throw new Error("Cannot access depth before activating.");if(null==this.#B)throw new Error("Expected “this.#depth” to be non-nullish.");return this.#B}#R(t){if(null!==this.#B)throw new Error("Expected “this.#depth” to be null.");this.#B=t}constructor(t){this.injector=t,this.#V=this.Inject(u),this.traits=new d,this.#F=t.resolve(S);const e=this.injector.resolve(N);this.childrenManager=new I(this,e),this.traits.set(this.#V.childrenAccessor,this.childrenManager.createAccessor()),this.traits.set(this.#V.debuggingName,this.constructor.name)}#P=new Set;#O=new Set;Input(t=null){const e=new k(t);this.#P.add(e);const n=e.observe((()=>this.markAsDirty()));return this.#d.add(n),e}Output(){const t=new E;return this.#O.add(t),t}emit(t,e=null){if(this.destroyed)throw new Error("An attempt was made to emit an output of a destroyed component.");if(!this.#O.has(t))throw new Error("An attempt was made to emit a foreign output.");t.emit(e)}Inject(t,e){return this.injector.resolve(t,e)}markAsDirty(){this.#F.markAsDirty(this)}#M=!1;#w=!1;get activated(){return this.#M}get destroyed(){return this.#w}activate(t){if(this.#M)throw new Error("Already activated.");this.#R(t.depth),this.#M=!0}update(){if(!this.#M)throw new Error("Cannot update before activation.");if(this.#w)throw new Error("Cannot update after it's been destroyed.");this.onUpdate();for(const t of this.#P)t.ratify();this.#F.markAsPristine(this)}destroy(){if(!this.#M)throw new Error("Cannot destroy before activation.");if(this.#w)throw new Error("Already destroyed.");this.#L=null;for(const t of this.#P)t.destroy();for(const t of this.#d)t.conclude();this.#d.clear(),this.#w=!0}childrenManager;#L=null;get parent(){if(null==this.#L)throw new Error("Expected “this.#parent” to be non-nullish.");return this.#L}acceptParent(t){if(null!=this.#L)throw new Error("The parent cannot be changed.");this.#L=t}}class P extends T{static Create(t){return new P(t)}constructor(t){super(t)}destroy(){super.destroy()}}class O{static Transparent=new O(0,0,0,0);static White=new O(1,1,1);static Black=new O(0,0,0);static Red=new O(1,0,0);static Green=new O(0,1,0);static Blue=new O(0,0,1);static Yellow=new O(1,1,0);static Magenta=new O(1,0,1);static Cyan=new O(0,1,1);static LightGray=new O(.25,.25,.25);static Gray=new O(.5,.5,.5);static DarkGray=new O(.75,.75,.75);#U;uint32_rgba;constructor(t=0,e=0,n=0,r=1){const i=U(t),s=U(e),o=U(n),a=U(r);this.#U=[i,s,o,a];const c=L(i),u=L(s),l=L(o),h=L(a);this.uint32_rgba=h|l<<8|u<<16|c<<24}static Multiply(t,e){const n=t.#U[0]*e.#U[0],r=t.#U[1]*e.#U[1],i=t.#U[2]*e.#U[2],s=t.#U[3]*e.#U[3];return new O(n,r,i,s)}}function L(t){return 255*t|0}function U(t){return t<0?0:t>1?1:t}class _{#_=new Array;get size(){return this.#_.length}peekAtFront(){return this.#_.at(0)}peekAtBack(){return this.#_.at(-1)}popFromFront(){return this.#_.shift()}popFromBack(){return this.#_.pop()}pushToFront(t){this.#_.unshift(t)}pushToBack(t){this.#_.push(t)}}class ${mustBreak;constructor(t){this.mustBreak=t}}class j extends ${static Instance=new j;constructor(){super(!1)}execute(){}}class W extends ${static Instance=new W;constructor(){super(!0)}execute(){}}class z extends ${#$;constructor(t,e){super(t),this.#$=e}execute(){for(const t of this.#$)t.execute()}}class G{renderer;processorStorage;frame;frameStorage;scheduleProcessing;constructor(t,e,n,r){this.renderer=t,this.processorStorage=e,this.frame=n,this.frameStorage=new d,this.scheduleProcessing=r}repurposeFor(t){this.frame=t,this.frameStorage.clear()}}class q{#j;#W;#z;#G=new _;#q;constructor(t,e){this.#j=t,this.#W=e,this.#z=new d,this.#W.onProcessorCreated(this.#j,this.#z),this.#q=new G(this.#j,this.#z,Symbol(),(t=>{this.#G.pushToFront(t)}))}renderFrame(t){const e=Symbol();this.#q.repurposeFor(e),this.#W.onFrameStart(this.#q),this.#K(t);let n=1e4;for(;this.#G.size>0;){const t=this.#G.popFromFront();if(this.#K(t),n--,n<0)throw new Error("Went insane!")}this.#j.flush(),this.#W.onFrameFinish(this.#q)}#K(t){let e=this.#W.process(t,this.#q);if(e.mustBreak&&(e.execute(),this.#j.flush(),e=this.#W.process(t,this.#q),e.mustBreak))throw new Error("A stubborn nugget indeed!");e.execute()}}const K=class{#Y;constructor(t){this.#Y=Array.from(t)}onProcessorCreated(t,e){for(const n of this.#Y)n.onProcessorCreated(t,e)}onFrameStart(t){for(const e of this.#Y)e.onFrameStart(t)}process(t,e){const n=[];let r=!1;for(const i of this.#Y){const s=i.process(t,e);if(s.mustBreak){r=!0;break}n.push(s)}return r?this.createBreakCommand(t,e):new z(!1,n)}createBreakCommand(t,e){const n=this.#Y.map((n=>n.createBreakCommand(t,e)));return new z(!0,n)}onFrameFinish(t){for(const e of this.#Y)e.onFrameFinish(t)}};class Y{#V;constructor(t){this.#V=t}onProcessorCreated(){}onFrameStart(){}process(t){return t.get(this.#V.debuggingName),j.Instance}createBreakCommand(){return W.Instance}onFrameFinish(){}}class H{#H=0;get nodesCount(){return this.#H}reset(){this.#H=0}extractStats(t){this.#H++}prettyPrint(){return`Nodes count: ${this.nodesCount}`}}class X{#X=new H;onProcessorCreated(){}process(t,e){return this.#X.extractStats(e),j.Instance}createBreakCommand(){return W.Instance}onFrameStart(){this.#X.reset()}onFrameFinish(){}}class Q{}class Z extends Q{#Q;constructor(t=Date.now()){super(),this.#Q=t}get tNow(){return Date.now()-this.#Q}}class J{}class tt{tStart;unsubscribe;#Z;#J={tGlobal:0,tLocal:0,elapsed:0};#tt=0;constructor(t,e,n){this.tStart=t,this.unsubscribe=n,this.#Z=e}invoke(t){this.#J.tGlobal=t,this.#J.tLocal=t-this.tStart,this.#J.elapsed=t-this.#tt,this.#Z(this.#J),this.#tt=t}}class et extends J{constructor(t){super(),this.#et=t}#et;#nt=new Set;#rt=null;get tGlobal(){return this.#et.tNow}subscribe(t){const e=this.#nt.size,n=new tt(this.#et.tNow,t,(()=>this.#it(n)));return this.#nt.add(n),0==e&&(this.#rt=requestAnimationFrame(this.#st)),n}#it(t){0!=this.#nt.size&&(this.#nt.delete(t),0==this.#nt.size&&(cancelAnimationFrame(this.#rt),this.#rt=null))}#st=()=>{const t=this.#et.tNow;for(const e of this.#nt)e.invoke(t);this.#rt=requestAnimationFrame(this.#st)};destroy(){this.#nt.clear(),null!=this.#rt&&(cancelAnimationFrame(this.#rt),this.#rt=null)}}class nt{#V;#ot;constructor(t,e){this.#V=t,this.#ot=null==e?.undoEligibilityTraits?null:new Set(e.undoEligibilityTraits)}onProcessorCreated(){}onFrameStart(){}process(t,{scheduleProcessing:e}){if(null==t.get(this.#V.undo)){let n=!1;if(null==this.#ot)n=!0;else for(const e of this.#ot)if(t.has(e)){n=!0;break}if(n){const n=(new d).set(this.#V.undo,t);if(null!=this.#V.debuggingName){const e=t.get(this.#V.debuggingName)??"?";n.set(this.#V.debuggingName,`Undo for "${e}"`)}e(n)}}const n=t.get(this.#V.childrenAccessor);if(null!=n)for(const t of n.iterate())e(t);return j.Instance}createBreakCommand(){return W.Instance}onFrameFinish(){}}class rt extends R{#at=!1;#ct=new Array;onUpdate(){this.#at?this.#ut():(this.#lt(),this.#at=!0)}#ht=null;#lt(){const t=(e=this.template,Array.isArray(e)?e:[e]);var e;this.#ht=t;for(const e of t){const t=this.childrenManager.createAt(this.childrenManager.count,e.componentDefinition);for(const[n,r]of e.bindings){const e=t[n];if(!x(e))throw new Error("unsupported dock type");m(r)?e.link(r):e.set(r)}if(null!=e.children){if(!("children"in t)||!x(t.children))throw new Error("this component does not support children");{class n extends rt{template=e.children}t.children.set(n)}}t.update()}}#ut(){}onDestroy(){this.#ct.splice(0,this.#ct.length)}}const it=Symbol("@morkite/template/INLINE_TEMPLATE_BASED_COMPONENT_DEFINITION");class st extends N{instantiate(t,e){if(null==(n=t)||"object"!=typeof n||!(it in n)||!0!==n[it])return null;var n;const r=t.api,i=t.templateFactory,s=new class extends rt{constructor(t){super(t),Object.entries(r).forEach((([t,e])=>{if(function(t){return null!=t&&"object"==typeof t&&(ot in t||at in t)}(e))Object.defineProperty(this,t,{value:this.Input(e.defaultValueFactory),enumerable:!0,configurable:!0,writable:!0});else{if(!function(t){return null!=t&&"object"==typeof t&&ut in t}(e))throw console.error(e),new Error("Expected an input.");Object.defineProperty(this,t,{value:this.Output(),enumerable:!0,configurable:!0,writable:!0})}})),this.template=i(this)}template}(e);return s}}const ot=Symbol(),at=Symbol();function ct(t=null){return null==t?{[ot]:void 0,defaultValueFactory:null}:{[at]:void 0,defaultValueFactory:t}}const ut=Symbol();function lt(t,e){return{[it]:!0,api:t,templateFactory:e}}function ht(t){return new pt(t)}class pt{componentDefinition;#pt=new Map;#E=null;get bindings(){return this.#pt}get children(){return this.#E}constructor(t){this.componentDefinition=t}bind(t,e){return this.#pt.set(t,e),this}setChildren(t){return this.#E=t,this}}class dt extends R{condition=this.Input();children=this.Input();onUpdate(){if(this.condition.didChange)if(1==this.condition.value&&0==this.childrenManager.count){this.childrenManager.createAt(0,this.children.value).update()}else 0==this.condition.value&&1==this.childrenManager.count&&this.childrenManager.count>0&&this.childrenManager.destroyAt(0)}onDestroy(){}}function ft(t){return t}class mt extends R{items=this.Input();tracker=this.Input((()=>ft));itemComponent=this.Input();#dt=[];#ft;constructor(t){super(t);const e=this.childrenManager,n=this.itemComponent;this.#ft={at:t=>e.at(t),createAt(t,r){const i=n.value,s=e.createAt(t,i);return s.item.set(r),s.index.set(t),s.update(),s},destroyAt(t){e.destroyAt(t)},ejectAt:t=>e.ejectAt(t),reinsertAt(t,n){e.reinsertAt(t,n)},destroyEjected(t){e.destroyEjected(t)}}}onUpdate(){if(this.items.didChange){const t=Array.from(this.items.value);!function(t,e,n,r){const i=new Map;let s=0,o=0,a=1e4;for(;;){if(a--,0==a)throw new Error("almost went insane");if(s>=t.length)break;if(o>=e.length)break;const c=n(t[s]),u=n(e[o]);if(c===u){s++,o++;continue}const l=i.get(u);if(null!=l){r.reinsertAt(o,l),i.delete(u),o++;continue}const h=r.ejectAt(o);i.set(c,h),s++}if(s>=t.length)for(;o<e.length;o++){const t=e[o],s=n(t),a=i.get(s);null!=a?(r.reinsertAt(o,a),i.delete(s)):r.createAt(o,t)}if(o>=e.length){for(;s<t.length;s++)r.destroyAt(o);for(const t of i.values())r.destroyEjected(t);i.clear()}}(this.#dt,t,this.tracker.value,this.#ft),this.#dt=t}}onDestroy(){}}class gt{pixelScale=P.Create(20)}function wt(t=0,e=0){return[t,e]}const yt=Ct(1,0,0),bt=Ct(-1,0,0),Tt=Ct(0,1,0),vt=Ct(0,-1,0),xt=Ct(0,0,1),kt=Ct(0,0,-1);function Ct(t=0,e=0,n=0){return[t,e,n]}function Dt(t){return t[0]}function Et(t){return t[1]}function It(t){return t[2]}function St(t,e,n,r){return function(t,e){t[0]=e}(t,e),function(t,e){t[1]=e}(t,n),function(t,e){t[2]=e}(t,r),t}function At(t,e){return St(t,Dt(e),Et(e),It(e))}function Nt(t,e,n){return St(t,Dt(e)-Dt(n),Et(e)-Et(n),It(e)-It(n))}function Ft(t,e,n){return St(t,e*Dt(n),e*Et(n),e*It(n))}function Bt(t,e){const n=1/function(t){const[e,n,r]=t;return Math.hypot(e,n,r)}(e);return Ft(t,n,e)}function Vt(t){return t[0]}function Mt(t){return t[1]}function Rt(t){return t[0]}function Pt(t){return t[1]}function Ot(t){return t[2]}function Lt(t){return t[3]}function Ut(t=0,e=0,n=0,r=0){return[t,e,n,r]}function _t(t=1,e=0,n=0,r=0,i=1,s=0,o=0,a=0,c=1,u=0,l=0,h=0){return[t,e,n,r,i,s,o,a,c,u,l,h]}const $t=_t();function jt(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t}function Wt(t,e,n){const[r,i,s,o,a,c,u,l,h,p,d,f]=e,[m,g,w,y,b,T,v,x,k,C,D,E]=n;return t[0]=r*m+o*g+u*w,t[1]=i*m+a*g+l*w,t[2]=s*m+c*g+h*w,t[3]=r*y+o*b+u*T,t[4]=i*y+a*b+l*T,t[5]=s*y+c*b+h*T,t[6]=r*v+o*x+u*k,t[7]=i*v+a*x+l*k,t[8]=s*v+c*x+h*k,t[9]=r*C+o*D+u*E+p,t[10]=i*C+a*D+l*E+d,t[11]=s*C+c*D+h*E+f,t}function zt(t,e){const[n,r,i,s,o,a,c,u,l]=e,h=function(t){const[e,n,r,i,s,o,a,c,u]=t;return e*s*u+i*c*r+a*n*o-e*c*o-i*n*u-a*s*r}(e);return t[0]=(o*l-u*a)/h,t[1]=-(r*l-u*i)/h,t[2]=(r*a-o*i)/h,t[3]=-(s*l-c*a)/h,t[4]=(n*l-c*i)/h,t[5]=-(n*a-s*i)/h,t[6]=(s*u-c*o)/h,t[7]=-(n*u-c*r)/h,t[8]=(n*o-s*r)/h,t}function Gt(t,e,n){const[r,i,s,o,a,c,u,l,h]=e,[p,d,f]=n;return t[0]=r*p+o*d+u*f,t[1]=i*p+a*d+l*f,t[2]=s*p+c*d+h*f,t}function qt(t,e){const[n,r,i,s,o,a,c,u,l,h,p,d]=e,f=[n,r,i,s,o,a,c,u,l];zt(f,f);const m=[h,p,d];return Gt(m,f,m),function(t,e){St(t,-Dt(e),-Et(e),-It(e))}(m,m),function(t,e,n,r,i,s,o,a,c,u,l,h,p){return t[0]=e,t[1]=n,t[2]=r,t[3]=i,t[4]=s,t[5]=o,t[6]=a,t[7]=c,t[8]=u,t[9]=l,t[10]=h,t[11]=p,t}(t,...f,...m)}const Kt=new p("Z_INDEX"),Yt=new p("WORLD_TILE_TYPE"),Ht={Terrain:Symbol("Terrain"),Player:Symbol("Player"),Box:Symbol("Box"),LaserEmittingBox:Symbol("LaserEmittingBox"),Laser:Symbol("Laser"),Fan:Symbol("Fan")},Xt=new s("@morkite/webgl-components/3d/TRI_TRAIT_TOKENS"),Qt=new s("@morkite/webgl-components/3d/CUBOID_TRAIT_TOKENS");class Zt{static Unit=new Zt;#mt;get matrix(){return this.#mt}constructor(){this.#mt=_t()}apply(t,e){return function(t,e,n){const[r,i,s]=n;return t[0]=e[0]*r+e[3]*i+e[6]*s+e[9],t[1]=e[1]*r+e[4]*i+e[7]*s+e[10],t[2]=e[2]*r+e[5]*i+e[8]*s+e[11],t}(t,this.#mt,e)}assign(t){return jt(this.#mt,t.matrix),this}clone(){const t=new Zt;return t.assign(this),t}resetToUnit(){return jt(this.#mt,$t),this}applyTransform(t){return Wt(this.#mt,t.matrix,this.matrix),this}applyTransformWithin(t){return Wt(this.#mt,this.matrix,t.matrix),this}scale(t,e,n){var r,i,s,o;return r=this.#mt,i=t,s=e,o=n,r[0]*=i,r[1]*=s,r[2]*=o,r[3]*=i,r[4]*=s,r[5]*=o,r[6]*=i,r[7]*=s,r[8]*=o,r[9]*=i,r[10]*=s,r[11]*=o,this}scaleWithin(t,e,n){var r,i,s,o;return r=this.#mt,i=t,s=e,o=n,r[0]*=i,r[1]*=i,r[2]*=i,r[3]*=s,r[4]*=s,r[5]*=s,r[6]*=o,r[7]*=o,r[8]*=o,this}translate(t,e,n){return function(t,e,n,r){t[9]+=e,t[10]+=n,t[11]+=r}(this.#mt,t,e,n),this}translateWithin(t,e,n){return function(t,e,n,r){t[9]+=t[0]*e+t[3]*n+t[6]*r,t[10]+=t[1]*e+t[4]*n+t[7]*r,t[11]+=t[2]*e+t[5]*n+t[8]*r}(this.#mt,t,e,n),this}rotateAroundX(t){return function(t,e){const n=Math.cos(e),r=Math.sin(e),[i,s,o,a,c,u,l,h,p,d,f,m]=t;t[0]=i,t[1]=n*s-r*o,t[2]=r*s+n*o,t[3]=a,t[4]=n*c-r*u,t[5]=r*c+n*u,t[6]=l,t[7]=n*h-r*p,t[8]=r*h+n*p,t[9]=d,t[10]=n*f-r*m,t[11]=r*f+n*m}(this.#mt,t),this}rotateAroundY(t){return function(t,e){const n=Math.cos(e),r=Math.sin(e),[i,s,o,a,c,u,l,h,p,d,f,m]=t;t[0]=n*i+r*o,t[1]=s,t[2]=-r*i+n*o,t[3]=a,t[4]=c,t[5]=u,t[6]=n*l+r*p,t[7]=h,t[8]=-r*l+n*p,t[9]=n*d+r*m,t[10]=f,t[11]=-r*d+n*m}(this.#mt,t),this}rotateAroundZ(t){return function(t,e){const n=Math.cos(e),r=Math.sin(e),[i,s,o,a,c,u,l,h,p,d,f,m]=t;t[0]=n*i-r*s,t[1]=r*i+n*s,t[2]=o,t[3]=n*a-r*c,t[4]=r*a+n*c,t[5]=u,t[6]=n*l-r*h,t[7]=r*l+n*h,t[8]=p,t[9]=n*d-r*f,t[10]=r*d+n*f,t[11]=m}(this.#mt,t),this}inverse(){return qt(this.#mt,this.matrix),this}toString(){return`Transform3[${this.#mt.join("|")}]`}}class Jt{#V;#gt;constructor(t,e){this.#V=t,this.#gt=e}onProcessorCreated(){}onFrameStart(){}process(t,{renderer:e,frameStorage:n}){const r=n.get(this.#gt.worldTransform)??Zt.Unit,i=t.get(this.#V.geometry),s=t.get(this.#V.geometryElements),o=t.get(this.#V.vertexNormals);if(null==i&&null==s&&null==o)return j.Instance;if(null==i||null==s||null==o)return j.Instance;let a=e.canAttributeBufferAccommodate(i.length);if(a&&=e.canElementsBufferAccommodate(s.length),!a)return new ee;const c=i.map((t=>At(Ct(),t))).map((t=>r.apply(t,t))),u=function(t,e){const[n,r,i,s,o,a,c,u,l]=e;return function(t,e,n,r,i,s,o,a,c,u){return t[0]=e,t[1]=n,t[2]=r,t[3]=i,t[4]=s,t[5]=o,t[6]=a,t[7]=c,t[8]=u,t}(t,n,r,i,s,o,a,c,u,l)}(function(t=0,e=0,n=0,r=0,i=0,s=0,o=0,a=0,c=0){return[t,e,n,r,i,s,o,a,c]}(),r.matrix);zt(u,u),function(t,e){const[n,r,i,s,o,a,c,u,l]=e;t[0]=n,t[1]=s,t[2]=c,t[3]=r,t[4]=o,t[5]=u,t[6]=i,t[7]=a,t[8]=l}(u,u);const l=o.map((t=>At(Ct(),t))).map((t=>Gt(t,u,t)));return new te(t,e,c,l,s,this.#V)}createBreakCommand(){return new ee}onFrameFinish(){}}class te extends ${nugget;renderer;worldPosition;vertexNormals;elements;traitTokens;constructor(t,e,n,r,i,s){super(!1),this.nugget=t,this.renderer=e,this.worldPosition=n,this.vertexNormals=r,this.elements=i,this.traitTokens=s}execute(){const t=this.nugget.get(this.traitTokens.tintColor)??O.White;for(let e=0;e<this.worldPosition.length;e++)this.renderer.writeToAttributeBuffer(this.worldPosition[e],this.vertexNormals[e],t);this.renderer.writeToElementsBuffer(this.worldPosition.length,this.elements)}}class ee extends ${constructor(){super(!0)}execute(){}}class ne{onProcessorCreated(){}onFrameStart({renderer:t}){t.clearColorBufferBit()}process(){return j.Instance}createBreakCommand(){return W.Instance}onFrameFinish(){}}class re{#V;#gt;constructor(t,e){this.#V=t,this.#gt=e}onProcessorCreated(){}onFrameStart(t){t.frameStorage.set(this.#gt.worldTransform,new Zt)}process(t,{frameStorage:e}){const n=t.get(this.#V.undo);if(null!=n){const t=n.get(this.#V.localTransform);if(null!=t){const n=t.clone().inverse();e.get(this.#gt.worldTransform,{onMiss:"throw"}).applyTransformWithin(n)}}const r=t.get(this.#V.localTransform);if(null!=r){const n=e.get(this.#gt.worldTransform,{onMiss:"throw"});n.applyTransformWithin(r);let i=t.get(this.#V.worldTransform);null==i&&(i=new Zt,t.set(this.#V.worldTransform,i)),i.assign(n)}return j.Instance}createBreakCommand(){return W.Instance}onFrameFinish(){}}class ie{#V;constructor(t){this.#V=t}onProcessorCreated(){}onFrameStart(){}process(t,e){const n=t.get(this.#V.projection);return null==n||e.renderer.setProjectionMatrix([...n]),j.Instance}createBreakCommand(){return W.Instance}onFrameFinish(){}}class se{#V;constructor(t){this.#V=t}onProcessorCreated(){}onFrameStart(){}process(t,e){const n=t.get(this.#V.directionalLight);return null!=n&&e.renderer.setLightDirection([...n]),j.Instance}createBreakCommand(){return W.Instance}onFrameFinish(){}}function oe(t,e,n){const r=t.createShader(e);if(null==r)throw new Error("Could not create a shader.");t.shaderSource(r,n),t.compileShader(r);if(!t.getShaderParameter(r,t.COMPILE_STATUS))throw console.error(t.getShaderInfoLog(r)),new Error("Could not compile the shader.");return r}function ae(t){return{kind:"directive",text:t}}function ce(t){return{kind:"identifier",name:"string"==typeof t?t:t.name}}function ue(t){return"string"==typeof t?{kind:"identifier",name:t}:t}function le(t,e,n,r,i){return{kind:"storage-declaration",storageQualifier:t,type:e,name:ce(n),arrayLength:r??null,interpolationQualifier:i??null}}function he(t,e,n,r){return{kind:"function-declaration",returnType:t,name:ce(e),parameters:n,body:r}}function pe(t,e,n){return{kind:"assignment",operator:t,left:ue(e),right:n}}function de(t,e){return{kind:"function-call",functionName:ce(t),arguments:e}}function fe(t){return{kind:"comment",text:t}}function me(t){return{kind:"program",items:t}}class ge{print(t){switch(t.kind){case"directive":return this.printDirective(t);case"identifier":return this.printIdentifier(t);case"literal":return this.printLiteral(t);case"variable-declaration":return this.printVariableDeclaration(t);case"storage-declaration":return this.printStorageDeclaration(t);case"precision-declaration":return this.printPrecisionDeclaration(t);case"function-parameter":return this.printFunctionParameter(t);case"function-declaration":return this.printFunctionDeclaration(t);case"unary-expression":return this.printUnaryExpression(t);case"binary-expression":return this.printBinaryExpression(t);case"assignment":return this.printAssignment(t);case"function-call":return this.printFunctionCall(t);case"swizzle":return this.printSwizzle(t);case"index-expression":return this.printIndexExpression(t);case"comment":return this.printComment(t);case"switch-statement":return this.printSwitchStatement(t);case"switch-statement-case":return this.printSwitchStatementCase(t);case"break-statement":return this.printBreakStatement();case"return-statement":return this.printReturnStatement(t);case"program":return this.printProgram(t)}}printDirective(t){return`#${t.text}`}printIdentifier(t){return t.name}printLiteral(t){return t.raw}printVariableDeclaration(t){return null==t.initializer?`${t.type} ${this.printIdentifier(t.name)};`:`${t.type} ${this.printIdentifier(t.name)} = ${this.printExpression(t.initializer)};`}printStorageDeclaration(t){let e=this.printIdentifier(t.name);return null!=t.arrayLength&&(e=`${e}[${t.arrayLength}]`),e=`${t.storageQualifier} ${t.type} ${e}`,null!=t.interpolationQualifier&&(e=`${t.interpolationQualifier} ${e}`),e=`${e};`,e}printPrecisionDeclaration(t){return`precision ${t.qualifier} ${t.type};`}printFunctionParameter(t){return null==t.qualifier?`${t.type} ${this.printIdentifier(t.name)}`:`${t.qualifier} ${t.type} ${this.printIdentifier(t.name)}`}printFunctionDeclaration(t){const e=t.body.map((t=>"  "+this.printStatement(t))).join("\n"),n=t.parameters.map((t=>this.printFunctionParameter(t))).join(", ");return[`${t.returnType} ${this.printIdentifier(t.name)} (${n}) {`,e,"}"].join("\n")}printUnaryExpression(t){return`${t.operator}(${this.printExpression(t.operand)})`}printBinaryExpression(t){return`(${this.printExpression(t.leftOperand)}) ${t.operator} (${this.printExpression(t.rightOperand)})`}printFunctionCall(t){const e=t.arguments.map((t=>this.printExpression(t))).join(", ");return`${this.printIdentifier(t.functionName)}(${e})`}printExpression(t){switch(t.kind){case"literal":return this.printLiteral(t);case"identifier":return this.printIdentifier(t);case"unary-expression":return this.printUnaryExpression(t);case"binary-expression":return this.printBinaryExpression(t);case"function-call":return this.printFunctionCall(t);case"swizzle":return this.printSwizzle(t);case"index-expression":return this.printIndexExpression(t)}}printAssignment(t){return`${this.printExpression(t.left)} ${t.operator} ${this.printExpression(t.right)};`}printSwizzle(t){return`(${this.printExpression(t.target)}).${t.mask}`}printIndexExpression(t){return`(${this.printExpression(t.target)})[${this.printExpression(t.index)}]`}printComment(t){return t.text.split("\n").map((t=>`// ${t}`)).join("\n")}printSwitchStatement(t){let e=`switch (${this.printExpression(t.discriminant)}) {`;for(const n of t.cases)e+=`\n  ${this.printSwitchStatementCase(n)}`;return e+="\n}",e}printSwitchStatementCase(t){let e=null==t.test?"default: {":`case ${this.printExpression(t.test)}: {`;for(const n of t.consequences)e+=`\n  ${this.printStatement(n)}`;return e+="\n}",e}printBreakStatement(){return"break;"}printReturnStatement(t){return`return ${this.printExpression(t.expression)};`}printStatement(t){switch(t.kind){case"assignment":return this.printAssignment(t);case"variable-declaration":return this.printVariableDeclaration(t);case"comment":return this.printComment(t);case"switch-statement":return this.printSwitchStatement(t);case"break-statement":return this.printBreakStatement();case"return-statement":return this.printReturnStatement(t)}}printTopLevelDeclaration(t){switch(t.kind){case"storage-declaration":return this.printStorageDeclaration(t);case"precision-declaration":return this.printPrecisionDeclaration(t)}}printTopLevelItem(t){switch(t.kind){case"storage-declaration":case"precision-declaration":return this.printTopLevelDeclaration(t);case"function-declaration":return this.printFunctionDeclaration(t);case"directive":return this.printDirective(t);case"comment":return this.printComment(t)}}printProgram(t){return t.items.map((t=>this.printTopLevelItem(t))).join("\n")}}class we{glslSpecifier;constructor(t){this.glslSpecifier=t}}class ye extends we{kind="primitive";glslSpecifier;constructor(t){super(t),this.glslSpecifier=t}}new ye("int");const be=new ye("float");new ye("vec2");const Te=new ye("vec3"),ve=new ye("vec4");new ye("mat3");const xe=new ye("mat4");new ye("sampler2D");class ke{static Simply(t){const e=new ke;return e.expressions.push(t),e}dependencies=new Array;expressions=new Array;get singleSelfContainedExpression(){if(this.dependencies.length>0)throw new Error("Not implemented.");if(this.expressions.length>1)throw new Error("Not implemented.");if(0==this.expressions.length)throw new Error("No outputs?");return this.expressions[0]}}class Ce{#wt=0;taken=new Set;isTaken(t){return this.taken.has(t)}markAsTaken(t){if(this.isTaken(t))throw new Error(`The name “${t}” is already taken.`);this.taken.add(t)}spawnAndMarkAsTaken(){for(;;){const t="temp_"+this.#wt++;if(!this.isTaken(t))return this.markAsTaken(t),t}}spawnManyAndMarkAsTaken(t){const e=new Array;for(let n=0;n<t;n++)e.push(this.spawnAndMarkAsTaken());return e}}class De{type;graphNode;index;constructor(t,e,n){this.type=t,this.graphNode=e,this.index=n}}class Ee{definition;graphNodeInstance;constructor(t,e){this.definition=t,this.graphNodeInstance=e}#yt=null;get incomingConnection(){return this.#yt}connectFrom(t,e=!1){if(null!=this.#yt)throw new Error("Input already connected. This error could mean an invalid state (TODO).");this.#yt=t,e||t.connectTo(this,!0)}removeIncomingConnection(t=!1){if(null==this.#yt)throw new Error("Input not connected. This error could mean an invalid state (TODO).");t||this.#yt.removeOutgoingConnection(this,!0);const e=this.#yt;return this.#yt=null,e}#bt=new Set;get outgoingConnections(){return this.#bt}connectTo(t,e=!1){if(this.#bt.has(t))throw new Error("Already connected to that input. This error could mean an invalid state (TODO).");this.#bt.add(t),e||t.connectFrom(this,!0)}removeOutgoingConnection(t,e=!1){if(!this.#bt.has(t))throw new Error("Not connected to that input. This error could mean an invalid state (TODO).");return e||t.removeIncomingConnection(!0),this.#bt.delete(t),t}}class Ie{definition;inputLinks;outputLinks;get inputs(){return this.inputLinks}get outputs(){return this.outputLinks}constructor(t){this.definition=t,this.inputLinks=t.inputs.map((t=>new Ee(t,this))),this.outputLinks=t.outputs.map((t=>new Ee(t,this)))}}class Se{inputTypes;outputTypes;inputs;outputs;constructor(t,e){this.inputTypes=t,this.outputTypes=e,this.inputs=t.map(((t,e)=>new De(t,this,e))),this.outputs=e.map(((t,e)=>new De(t,this,e)))}createInstance(){return new Ie(this)}}class Ae extends Se{constructor(){super([be,be,be],[be])}generateAst(t,e,n,r){return ke.Simply(de("clamp",[e,n,r]))}}class Ne{#Tt;#vt;constructor(t,e){this.#Tt=t,this.#vt=e}*initiallyScheduledLinks(){for(const t of this.#Tt.inputs)yield{kind:"input",link:t}}finalize(t,e,n){if(e.size!=this.#Tt.inputs.length)throw new Error(`workbench left with ${e.size} items in the end, bug. expected ${this.#Tt.inputs.length} which matches the number of inputs of this intermediate node.`);const r=new Array;for(;e.size>0;)r.push(e.popFromFront());const i=this.#Tt.definition.generateAst(n,...r);t.dependencies.push(...i.dependencies);let s=0;for(const e of this.#vt){const n=this.#Tt.outputs[s].definition.type,r=(o=n.glslSpecifier,a=ce(e),c=i.expressions[s],{kind:"variable-declaration",type:o,name:ce(a),initializer:c??null});t.dependencies.push(r),s++}var o,a,c}getOutputNameFor(t){if(!this.#Tt.outputs.includes(t))throw new Error("Not an output for this node?");return this.#vt[t.definition.index]}}class Fe{#xt;constructor(t){this.#xt=Array.from(t)}*initiallyScheduledLinks(){for(const t of this.#xt)yield{kind:"input",link:t}}finalize(t,e){if(e.size!=this.#xt.length)throw new Error(`workbench left with ${e.size} items in the end, bug. expected ${this.#xt.length}, which matches the number of outputs of this node`);for(;e.size>0;)t.expressions.push(e.popFromFront())}}class Be{definition;graphNodeInstance;constructor(t,e){this.definition=t,this.graphNodeInstance=e}#bt=new Set;get outgoingConnections(){return this.#bt}connectTo(t,e=!1){if(this.#bt.has(t))throw new Error("Already connected to that input. This error could mean an invalid state (TODO).");this.#bt.add(t),e||t.connectFrom(this,!0)}removeOutgoingConnection(t,e=!1){if(!this.#bt.has(t))throw new Error("Not connected to that input. This error could mean an invalid state (TODO).");return e||t.removeIncomingConnection(!0),this.#bt.delete(t),t}}class Ve{definition;graphNodeInstance;constructor(t,e){this.definition=t,this.graphNodeInstance=e}#yt=null;get incomingConnection(){return this.#yt}connectFrom(t,e=!1){if(null!=this.#yt)throw new Error("Input already connected. This error could mean an invalid state (TODO).");this.#yt=t,e||t.connectTo(this,!0)}removeIncomingConnection(t=!1){if(null==this.#yt)throw new Error("Input not connected. This error could mean an invalid state (TODO).");t||this.#yt.removeOutgoingConnection(this,!0);const e=this.#yt;return this.#yt=null,e}}class Me extends Se{inputDefinitions;outputDefinitions;#kt;constructor(t,e){super(t,e),this.#kt=this.createInstance(),this.inputDefinitions=this.inputs.map((t=>new Be(t,this.#kt))),this.outputDefinitions=this.outputs.map((t=>new Ve(t,this.#kt)))}generateAst(t,...e){return function(t,e,n,r){const i=new ke,s=new Map,o=new _;for(o.pushToFront(new Fe(t));o.size>0;){const t=o.popFromFront(),a=new _,c=new _;for(const e of t.initiallyScheduledLinks())c.pushToFront(e);for(;c.size>0;){const t=c.popFromFront();if("input"==t.kind){if(null==t.link.incomingConnection)throw new Error(`broken graph? looks like ${t.link.definition.graphNode.constructor.name}'s input ${t.link.definition.index} is not connected to anything`);if(e(t.link.incomingConnection.definition.graphNode)){const e=r[t.link.incomingConnection.definition.index];if(null==e)throw new Error("not enough input expressions");a.pushToFront(e)}else{const e=t.link.incomingConnection.outgoingConnections.size>1,r=t.link.incomingConnection.definition.graphNode.outputs.length>1;if(e||r){let e=s.get(t.link.incomingConnection.graphNodeInstance);null==e&&(e=new Ne(t.link.incomingConnection.graphNodeInstance,n.spawnManyAndMarkAsTaken(t.link.incomingConnection.definition.graphNode.outputs.length)),s.set(t.link.incomingConnection.graphNodeInstance,e),o.pushToFront(e));const r=e.getOutputNameFor(t.link.incomingConnection);a.pushToFront(ce(r))}else{c.pushToFront({kind:"output",link:t.link.incomingConnection});for(let e=t.link.incomingConnection.definition.graphNode.inputs.length-1;e>=0;e-=1){const n=t.link.incomingConnection.graphNodeInstance.inputs[e];c.pushToFront({kind:"input",link:n})}}}}else if("output"==t.kind){const e=new Array;for(let n=0;n<t.link.definition.graphNode.inputs.length;n++){const t=a.popFromFront();if(null==t)throw new Error("not enough things on the workbench, algorithm error, bug");e.unshift(t)}const r=t.link.definition.graphNode.generateAst(n,...e);if(1!=r.expressions.length)throw new Error("shouldn't be on the stack if there's more than one expression (it would've started a new dependency for multi-output), and it wouldn't be discovered if it had no outputs (which is weird in its own merit)");i.dependencies.push(...r.dependencies),a.pushToFront(r.expressions[0])}}t.finalize(i,a,n)}return i}(this.outputDefinitions,(t=>t==this),t,e)}print(t=Re.Instance){const e=new Array,n=new Set;n.add(this.#kt);const r=new _;for(const t of this.inputDefinitions)r.pushToBack(t);for(;r.size>0;){const i=r.popFromFront(),s=i.graphNodeInstance==this.#kt?t.printHostInput(i.graphNodeInstance.definition,i.definition):t.printInnerOutput(i.graphNodeInstance.definition,i.definition),o=new Array;for(const e of i.outgoingConnections){const i=e.graphNodeInstance==this.#kt?t.printHostOutput(e.graphNodeInstance.definition,e.definition):t.printInnerInput(e.graphNodeInstance.definition,e.definition);if(o.push(i),!n.has(e.graphNodeInstance)){n.add(e.graphNodeInstance);for(const t of e.graphNodeInstance.outputs)r.pushToBack(t)}}e.push(`${s} -> ${o.join(", ")}`)}return e.join("\n")}}class Re{static Instance=new Re;printHostInput(t,e){return`$.in.${Oe(e)}`}printHostOutput(t,e){return`$.out.${Oe(e)}`}printInnerInput(t,e){return`${Pe(t)}.in.${Oe(e)}`}printInnerOutput(t,e){return`${Pe(t)}.out.${Oe(e)}`}}function Pe(t){return t.constructor.name}function Oe(t){return t.index.toString()}class Le extends Se{#Ct;constructor(t,e){super([],[t]),this.#Ct=function(t){return{kind:"literal",raw:"string"==typeof t?t:t.raw}}(e)}generateAst(){return ke.Simply(this.#Ct)}}class Ue extends Se{constructor(t){super([t,t],[be])}generateAst(t,e,n){return ke.Simply(de("dot",[e,n]))}}class _e extends Se{constructor(t){super([t],[t])}generateAst(t,e){return ke.Simply(e)}}class $e extends Se{constructor(t,e,n){super([t,e],[n])}generateAst(t,e,n){return ke.Simply({kind:"binary-expression",operator:"*",leftOperand:e,rightOperand:n})}}class je extends Se{constructor(t){super([t],[t])}generateAst(t,e){return ke.Simply({kind:"unary-expression",operator:"-",operand:e})}}class We extends Se{constructor(t){super([t],[t])}generateAst(t,e){return ke.Simply(de("normalize",[e]))}}class ze extends Se{static Create(t,e,n){return new ze(t,e,n)}mask;constructor(t,e,n){super([t],[e]),this.mask=n}generateAst(t,e){return ke.Simply((n=e,r=this.mask,{kind:"swizzle",target:ue(n),mask:r}));var n,r}}class Ge extends Se{constructor(t,e){super(t,[e])}generateAst(t,...e){return ke.Simply(de(this.outputs[0].type.glslSpecifier,e))}}class qe{kind="attribute";#t;type;constructor(t,e){this.#t=t,this.type=e}createVertexShaderReference(){return ce(this.#t)}createFragmentShaderReference(){throw new Error("Oops!")}createVertexShaderDeclaration(){return"array"==this.type.kind?le("in",this.type.elementType.glslSpecifier,this.#t,this.type.length):le("in",this.type.glslSpecifier,this.#t,null)}createFragmentShaderDeclaration(){throw new Error("Oops!")}getLocation(t,e){return t.getAttribLocation(e,this.#t)}isCompatibleInterpreter(t){return!0}print(){return`attribute/${this.#t}`}}class Ke{static From(t,e,n){const r=n.getLocation(t,e);return new Ke(n,r)}definition;#Dt;constructor(t,e){this.definition=t,this.#Dt=e}describeLayout(t,e,n){t.enableVertexAttribArray(this.#Dt),t.vertexAttribPointer(this.#Dt,e.componentsCount,e.dataType.glConstant,e.normalized,n.vertexByteSize,n.getByteOffsetViaAttribute(this))}}class Ye{kind="uniform";#t;type;constructor(t,e){this.#t=t,this.type=e}createReference(){return ce(this.#t)}createVertexShaderReference(){return this.createReference()}createFragmentShaderReference(){return this.createReference()}createDeclaration(){return"array"==this.type.kind?le("uniform",this.type.elementType.glslSpecifier,this.#t,this.type.length):le("uniform",this.type.glslSpecifier,this.#t,null)}createVertexShaderDeclaration(){return this.createDeclaration()}createFragmentShaderDeclaration(){return this.createDeclaration()}getLocation(t,e){return t.getUniformLocation(e,this.#t)}print(){return`uniform/${this.#t}`}}class He{definition;glLocation;constructor(t,e){this.definition=t,this.glLocation=e}}class Xe extends He{static From(t,e,n){const r=n.getLocation(t,e);if(null==r)throw new Error("Not implemented.");return new Xe(n,r)}set(t,e){t.uniformMatrix4fv(this.glLocation,!1,e)}}class Qe extends He{static From(t,e,n){const r=n.getLocation(t,e);if(null==r)throw new Error("Not implemented.");return new Qe(n,r)}set(t,e){t.uniform3fv(this.glLocation,e)}}class Ze{kind="varying";#t;type;#Et;constructor(t,e,n){this.#t=t,this.type=e,this.#Et=n?.interpolationQualifier??null}createReference(){return ce(this.#t)}createVertexShaderReference(){return this.createReference()}createFragmentShaderReference(){return this.createReference()}createDeclaration(t){return"array"==this.type.kind?le(t,this.type.elementType.glslSpecifier,this.#t,this.type.length,this.#Et):le(t,this.type.glslSpecifier,this.#t,null,this.#Et)}createVertexShaderDeclaration(){return this.createDeclaration("out")}createFragmentShaderDeclaration(){return this.createDeclaration("in")}print(){return`varying/${this.#t}`}}class Je extends Me{constructor(){super([Te,Te,ve],[ve]);const t=new We(Te).createInstance(),e=new We(Te).createInstance(),n=new je(Te).createInstance(),r=new Ue(Te).createInstance(),i=(new Ae).createInstance(),s=ze.Create(ve,Te,"rgb").createInstance(),o=ze.Create(ve,be,"a").createInstance(),a=new $e(be,Te,Te).createInstance(),c=new Ge([Te,be],ve).createInstance();this.inputDefinitions[0].connectTo(t.inputs[0]),this.inputDefinitions[1].connectTo(e.inputs[0]),e.outputs[0].connectTo(n.inputs[0]),t.outputs[0].connectTo(r.inputs[0]),n.outputs[0].connectTo(r.inputs[1]),r.outputs[0].connectTo(i.inputs[0]),new Le(be,"0.0").createInstance().outputs[0].connectTo(i.inputs[1]),new Le(be,"1.0").createInstance().outputs[0].connectTo(i.inputs[2]),i.outputs[0].connectTo(a.inputs[0]),this.inputDefinitions[2].connectTo(s.inputs[0]),s.outputs[0].connectTo(a.inputs[1]),a.outputs[0].connectTo(c.inputs[0]),this.inputDefinitions[2].connectTo(o.inputs[0]),o.outputs[0].connectTo(c.inputs[1]),c.outputs[0].connectTo(this.outputDefinitions[0])}}class tn{kind="implicit-varying";type=ve;createVertexShaderReference(){return ce("gl_Position")}createFragmentShaderReference(){return ce("gl_FragCoord")}createVertexShaderDeclaration(){return fe("out vec4 gl_Position (implicit)")}createFragmentShaderDeclaration(){return fe("in vec4 gl_FragCoord (implicit)")}print(){return"implicit_varying"}}class en{#t;type;constructor(t,e){this.#t=t,this.type=e}createReference(){return ce(this.#t)}createVertexShaderReference(){throw new Error("Oops!")}createFragmentShaderReference(){return this.createReference()}createDeclaration(){return"array"==this.type.kind?le("out",this.type.elementType.glslSpecifier,this.#t,this.type.length):le("out",this.type.glslSpecifier,this.#t,null)}createVertexShaderDeclaration(){throw new Error("Oops!")}createFragmentShaderDeclaration(){return this.createDeclaration()}print(){return`fragment_output/${this.#t}`}}class nn{#It;#o=new Map;#St=new Map;constructor(t){this.#It=t}set(t,e){if(e.graphNode!==this.#It)throw new Error("Oops!");if(this.#o.has(t))throw new Error("Oops!");if(this.#St.has(e))throw new Error("Oops!");this.#o.set(t,e),this.#St.set(e,t)}get(t){return this.#o.get(t)??null}getReverse(t){return this.#St.get(t)??null}*[Symbol.iterator](){for(const t of this.#It.inputs){const e=this.getReverse(t);yield[e,t]}}*inputDefinitions(){for(const[t]of this)null!=t&&(yield t)}*linkDefinitions(){for(const[,t]of this)yield t}}class rn{#It;#o=new Map;#St=new Map;constructor(t){this.#It=t}set(t,e){if(e.graphNode!==this.#It)throw new Error("Oops!");if(this.#o.has(t))throw new Error("Oops!");if(this.#St.has(e))throw new Error("Oops!");this.#o.set(t,e),this.#St.set(e,t)}get(t){return this.#o.get(t)??null}getReverse(t){return this.#St.get(t)??null}*[Symbol.iterator](){for(const t of this.#It.outputs){const e=this.getReverse(t);yield[e,t]}}*outputDefinitions(){for(const[t]of this)t&&(yield t)}*linkDefinitions(){for(const[,t]of this)yield t}}class sn{static Create(t,e,n){return new sn(t,e,n)}#It;#At;#Nt;get nodeDefinition(){return this.#It}get inputVariables(){return this.#At}get outputVariables(){return this.#Nt}constructor(t,e,n){this.#It=t,this.#At=new nn(t),this.#Nt=new rn(t);for(const[n,r]of e.entries())this.#At.set(r,t.inputs[n]);for(const[e,r]of n.entries())this.#Nt.set(r,t.outputs[e])}createAndCompileGlShader(t,e){const n=new Ce,r=this.#It.inputs.map((t=>this.#At.getReverse(t).createVertexShaderReference())),i=this.#It.generateAst(n,...r),s=this.#It.outputs.map((t=>this.#Nt.getReverse(t).createVertexShaderReference())),o=me([ae("version 300 es"),...this.#It.inputs.map((t=>this.#At.getReverse(t).createVertexShaderDeclaration())),...this.#It.outputs.map((t=>this.#Nt.getReverse(t).createVertexShaderDeclaration())),he("void","main",[],[...i.dependencies,...i.expressions.map(((t,e)=>pe("=",s[e],t)))])]),a=t.print(o);return oe(e,e.VERTEX_SHADER,a)}print(){if(this.#It instanceof Me)return this.#It.print(new on(this.inputVariables,this.outputVariables));throw new Error("Oops!")}applyModifications(...t){return t.reduce(((t,e)=>e.applyTo(t)),this)}}class on extends Re{#At;#Nt;constructor(t,e){super(),this.#At=t,this.#Nt=e}printHostInput(t,e){const n=this.#At.getReverse(e),r=null==n?"":"/"+n.print();return super.printHostInput(t,e)+r}printHostOutput(t,e){const n=this.#Nt.getReverse(e),r=null==n?"":"/"+n.print();return super.printHostOutput(t,e)+r}printInnerInput(t,e){return super.printInnerInput(t,e)}printInnerOutput(t,e){return super.printInnerOutput(t,e)}}class an{#It;#o=new Map;#St=new Map;constructor(t){this.#It=t}set(t,e){if(e.graphNode!==this.#It)throw new Error("Oops!");if(this.#o.has(t))throw new Error("Oops!");if(this.#St.has(e))throw new Error("Oops!");this.#o.set(t,e),this.#St.set(e,t)}get(t){return this.#o.get(t)??null}getReverse(t){return this.#St.get(t)??null}*[Symbol.iterator](){for(const t of this.#It.inputs){const e=this.getReverse(t);yield[e,t]}}*inputDefinitions(){for(const[t]of this)null!=t&&(yield t)}*linkDefinitions(){for(const[,t]of this)yield t}}class cn{#It;#o=new Map;#St=new Map;constructor(t){this.#It=t}set(t,e){if(e.graphNode!==this.#It)throw new Error("Oops!");if(this.#o.has(t))throw new Error("Oops!");if(this.#St.has(e))throw new Error("Oops!");this.#o.set(t,e),this.#St.set(e,t)}get(t){return this.#o.get(t)??null}getReverse(t){return this.#St.get(t)??null}*[Symbol.iterator](){for(const t of this.#It.outputs){const e=this.getReverse(t);yield[e,t]}}*outputDefinitions(){for(const[t]of this)t&&(yield t)}*linkDefinitions(){for(const[,t]of this)yield t}}class un{static Create(t,e,n){return new un(t,e,n)}#It;#At;#Nt;get nodeDefinition(){return this.#It}get inputVariables(){return this.#At}get outputVariables(){return this.#Nt}constructor(t,e,n){this.#It=t,this.#At=new an(t),this.#Nt=new cn(t);for(const[n,r]of e.entries())this.#At.set(r,t.inputs[n]);for(const[e,r]of n.entries())this.#Nt.set(r,t.outputs[e])}createAndCompileGlShader(t,e){const n=new Ce,r=this.#It.inputs.map((t=>this.#At.getReverse(t).createFragmentShaderReference())),i=this.#It.generateAst(n,...r),s=this.#It.outputs.map((t=>this.#Nt.getReverse(t).createFragmentShaderReference())),o=me([ae("version 300 es"),(a="highp",c="float",{kind:"precision-declaration",qualifier:a,type:c}),...this.#It.inputs.map((t=>this.#At.getReverse(t).createFragmentShaderDeclaration())),...this.#It.outputs.map((t=>this.#Nt.getReverse(t).createFragmentShaderDeclaration())),he("void","main",[],[...i.dependencies,...i.expressions.map(((t,e)=>pe("=",s[e],t)))])]);var a,c;const u=t.print(o);return oe(e,e.FRAGMENT_SHADER,u)}print(){if(this.#It instanceof Me)return this.#It.print(new ln(this.inputVariables,this.outputVariables));throw new Error("Oops!")}applyModifications(...t){return t.reduce(((t,e)=>e.applyTo(t)),this)}}class ln extends Re{#At;#Nt;constructor(t,e){super(),this.#At=t,this.#Nt=e}printHostInput(t,e){const n=this.#At.getReverse(e),r=null==n?"":"/"+n.print();return super.printHostInput(t,e)+r}printHostOutput(t,e){const n=this.#Nt.getReverse(e),r=null==n?"":"/"+n.print();return super.printHostOutput(t,e)+r}printInnerInput(t,e){return super.printInnerInput(t,e)}printInnerOutput(t,e){return super.printInnerOutput(t,e)}}class hn{}class pn extends hn{static Create(t,e,n){return new pn(t,e,n)}#It;#At;#Nt;constructor(t,e,n){super(),this.#It=t,this.#At=new nn(t),this.#Nt=new rn(t);for(const[n,r]of e.entries())this.#At.set(r,t.inputs[n]);for(const[e,r]of n.entries())this.#Nt.set(r,t.outputs[e])}applyTo(t){const e=this;for(const e of t.outputVariables.outputDefinitions())for(const t of this.#Nt.outputDefinitions())if(e==t)throw new Error("Oops!");const n=Array.from(this.#Nt.linkDefinitions()),r=new Map,i=new Array;for(const[e,n]of this.#At){const s=t.inputVariables.get(e);null==s?i.push(n):r.set(e,s)}const s=new class extends Me{constructor(){super([...t.nodeDefinition.inputTypes,...i.map((({type:t})=>t))],[...t.nodeDefinition.outputTypes,...n.map((({type:t})=>t))]);const s=t.nodeDefinition.createInstance(),o=e.#It.createInstance();for(let e=0;e<t.nodeDefinition.inputs.length;e++)this.inputDefinitions[e].connectTo(s.inputs[e]);for(const[t,n]of r){const r=e.#At.get(t);if(null==r)throw new Error("Expected “modInputLink” to be non-nullish.");const i=o.inputs[r.index];this.inputDefinitions[n.index].connectTo(i)}for(const[e,n]of i.entries()){const r=o.inputs[n.index];this.inputDefinitions[t.nodeDefinition.inputs.length+e].connectTo(r)}for(let e=0;e<t.nodeDefinition.outputs.length;e++)s.outputs[e].connectTo(this.outputDefinitions[e]);for(const[e,r]of n.entries()){const n=o.outputs[r.index],i=this.outputDefinitions[t.nodeDefinition.outputs.length+e];n.connectTo(i)}}};return new sn(s,[...t.inputVariables.inputDefinitions(),...i.map((t=>e.#At.getReverse(t)))],[...t.outputVariables.outputDefinitions(),...n.map((t=>e.#Nt.getReverse(t)))])}}class dn extends hn{static Create(t,e,n){return new dn(t,e,n)}#It;#At;#Ft;constructor(t,e,n){super(),this.#It=t,this.#At=new nn(t),this.#Ft=n;for(const[n,r]of e.entries())this.#At.set(r,t.inputs[n])}applyTo(t){const e=t.outputVariables.get(this.#Ft);if(null==e)throw new Error("Oops!");const n=this,r=new Map,i=new Array;for(const[e,n]of this.#At){if(null==e)continue;const s=t.inputVariables.get(e);null==s?i.push(n):r.set(e,s)}const s=new class extends Me{constructor(){super([...t.nodeDefinition.inputTypes,...i.map((({type:t})=>t))],[...t.nodeDefinition.outputTypes]);const s=t.nodeDefinition.createInstance(),o=n.#It.createInstance();for(let e=0;e<t.nodeDefinition.inputs.length;e++)this.inputDefinitions[e].connectTo(s.inputs[e]);for(const[t,e]of r){const r=n.#At.get(t);if(null==r)throw new Error("Expected “modInputLink” to be non-nullish.");const i=o.inputs[r.index];this.inputDefinitions[e.index].connectTo(i)}for(const[e,n]of i.entries()){const r=o.inputs[n.index];this.inputDefinitions[t.nodeDefinition.inputs.length+e].connectTo(r)}for(let n=0;n<t.nodeDefinition.outputs.length;n++)n==e.index?(s.outputs[n].connectTo(o.inputs[o.definition.inputs.length-1]),o.outputs[0].connectTo(this.outputDefinitions[n])):s.outputs[n].connectTo(this.outputDefinitions[n])}};return new sn(s,[...t.inputVariables.inputDefinitions(),...i.map((t=>n.#At.getReverse(t)))],[...t.outputVariables.outputDefinitions()])}}class fn{}class mn extends fn{static Create(t,e,n){return new mn(t,e,n)}#It;#At;#Ft;constructor(t,e,n){super(),this.#It=t,this.#At=new an(t),this.#Ft=n;for(const[n,r]of e.entries())this.#At.set(r,t.inputs[n])}applyTo(t){const e=t.outputVariables.get(this.#Ft);if(null==e)throw new Error("Oops!");const n=this,r=new Map,i=new Array;for(const[e,n]of this.#At){if(null==e)continue;const s=t.inputVariables.get(e);null==s?i.push(n):r.set(e,s)}const s=new class extends Me{constructor(){super([...t.nodeDefinition.inputTypes,...i.map((({type:t})=>t))],[...t.nodeDefinition.outputTypes]);const s=t.nodeDefinition.createInstance(),o=n.#It.createInstance();for(let e=0;e<t.nodeDefinition.inputs.length;e++)this.inputDefinitions[e].connectTo(s.inputs[e]);for(const[t,e]of r){const r=n.#At.get(t);if(null==r)throw new Error("Expected “modInputLink” to be non-nullish.");const i=o.inputs[r.index];this.inputDefinitions[e.index].connectTo(i)}for(const[e,n]of i.entries()){const r=o.inputs[n.index];this.inputDefinitions[t.nodeDefinition.inputs.length+e].connectTo(r)}for(let n=0;n<t.nodeDefinition.outputs.length;n++)n==e.index?(s.outputs[n].connectTo(o.inputs[o.definition.inputs.length-1]),o.outputs[0].connectTo(this.outputDefinitions[n])):s.outputs[n].connectTo(this.outputDefinitions[n])}};return new un(s,[...t.inputVariables.inputDefinitions(),...i.map((t=>n.#At.getReverse(t)))],[...t.outputVariables.outputDefinitions()])}}class gn{glProgram;attributes;uniforms;#Bt=new qe("a_VertexPosition",ve);#Vt=new qe("a_VertexNormal",Te);#Mt=new qe("a_VertexColor",ve);#Rt=new Ye("u_ProjectionMatrix",xe);#Pt=new Ye("u_LightDirection",Te);#Ot=new Ze("v_FragmentNormal",Te);#Lt=new Ze("v_FragmentColor",ve);#Ut=new tn;#_t=new en("out_Color",ve);constructor(t){const e=sn.Create(new _e(ve),[this.#Bt],[this.#Ut]),n=dn.Create(new $e(xe,ve,ve),[this.#Rt],this.#Ut),r=pn.Create(new _e(Te),[this.#Vt],[this.#Ot]),i=pn.Create(new _e(ve),[this.#Mt],[this.#Lt]),s=e.applyModifications(n,r,i),o=un.Create(new _e(ve),[this.#Lt],[this.#_t]),a=mn.Create(new Je,[this.#Pt,this.#Ot],this.#_t),c=o.applyModifications(a),u=new ge,l=function(t,e,n){const r=t.createProgram();if(null==r)throw new Error("Expected glProgram to be non-null.");if(t.attachShader(r,e),t.attachShader(r,n),t.linkProgram(r),!t.getProgramParameter(r,t.LINK_STATUS))throw console.error(t.getProgramInfoLog(r)),new Error("Oops!");return r}(t,s.createAndCompileGlShader(u,t),c.createAndCompileGlShader(u,t));this.glProgram=l,this.attributes={worldPosition:Ke.From(t,l,this.#Bt),vertexNormal:Ke.From(t,l,this.#Vt),tintColor:Ke.From(t,l,this.#Mt)},this.uniforms={projectionMatrix:Xe.From(t,l,this.#Rt),lightDirection:Qe.From(t,l,this.#Pt)}}}var wn;!function(t){t[t.BYTE=5120]="BYTE",t[t.UNSIGNED_BYTE=5121]="UNSIGNED_BYTE",t[t.SHORT=5122]="SHORT",t[t.UNSIGNED_SHORT=5123]="UNSIGNED_SHORT",t[t.INT=5124]="INT",t[t.UNSIGNED_INT=5125]="UNSIGNED_INT",t[t.FLOAT=5126]="FLOAT"}(wn||(wn={}));class yn{get byteSize(){return this.componentsCount*this.dataType.byteSize}}class bn extends yn{static Create(t){return new bn(t)}componentsCount;dataType={glConstant:wn.FLOAT,byteSize:4};normalized=!1;constructor(t){super(),this.componentsCount=t}}class Tn extends yn{static Create(t,e){return new Tn(t,e)}componentsCount;dataType={glConstant:wn.UNSIGNED_BYTE,byteSize:1};normalized;constructor(t,e){super(),this.componentsCount=t,this.normalized=e?.normalized??!1}}class vn{#$t=new Map;add(t,e){if(this.#$t.has(t))throw new Error("Oops!");return this.#$t.set(t,e),this}build(){const t=new xn(this.#$t);return this.#$t.clear(),t}}class xn{attributeInterpreters;vertexByteSize;#jt;#Wt;constructor(t){this.attributeInterpreters=new Map(t);let e=0;const n=new Array(this.attributeInterpreters.size),r=new Map;for(const[t,i]of this.attributeInterpreters)n[0]=e,r.set(t,e),e+=i.byteSize;this.vertexByteSize=e,this.#jt=n,this.#Wt=r}getByteOffsetViaIndex(t){if(!Number.isInteger(t))throw new Error("not an integer");if(t<0||t>=this.#jt.length)throw new Error("!?");return this.#jt[t]}getByteOffsetViaAttribute(t){const e=this.#Wt.get(t);if(null==e)throw new Error("!?");return e}describe(t){for(const[e,n]of this.attributeInterpreters)e.describeLayout(t,n,this)}}class kn{gl;#zt=3;#Gt=8192;#qt=this.#zt*this.#Gt;#Kt;#Yt;#Ht;#Xt;#Qt;#Zt;#Jt;#te;#ee=0;#ne=0;#re=1280;#ie=720;#se;constructor(t,e){this.gl=t,this.#se=e;const n=(new vn).add(this.#se.attributes.worldPosition,bn.Create(3)).add(this.#se.attributes.vertexNormal,bn.Create(3)).add(this.#se.attributes.tintColor,Tn.Create(4,{normalized:!0})).build();this.#Kt=n.vertexByteSize;const r=this.#Kt*this.#qt,i=this.#qt*Cn.int16,s=new ArrayBuffer(r),o=new ArrayBuffer(i);this.#Yt=new DataView(s),this.#Ht=0,this.#Xt=new DataView(o),this.#Qt=0;const a=this.gl.createVertexArray();if(null==a)throw new Error("Expected “vao” to be non-nullish.");this.#Zt=a,this.gl.bindVertexArray(this.#Zt);const c=this.gl.createBuffer();if(null==c)throw new Error("Expected “attributeDataGpuBuffer” to be non-nullish.");this.#Jt=c,this.gl.bindBuffer(this.gl.ARRAY_BUFFER,c),this.gl.bufferData(this.gl.ARRAY_BUFFER,r,this.gl.STREAM_DRAW),n.describe(t);const u=this.gl.createBuffer();if(null==u)throw new Error("Expected “elementArrayGpuBuffer” to be non-nullish.");this.#te=u,this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,this.#te),this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER,i,this.gl.DYNAMIC_DRAW),this.gl.bindVertexArray(null),this.gl.useProgram(this.#se.glProgram),this.setProjectionMatrix(new Float32Array([2/this.#re,0,0,0,0,2/this.#ie,0,0,0,0,-2/this.#re,0,0,0,0,1])),this.gl.viewport(0,0,this.gl.canvas.width,this.gl.canvas.height),this.gl.clearColor(.2,.2,.2,1),this.gl.enable(this.gl.BLEND),this.gl.blendFunc(this.gl.ONE,this.gl.ONE_MINUS_SRC_ALPHA),this.gl.enable(this.gl.CULL_FACE),this.gl.enable(this.gl.DEPTH_TEST)}canAttributeBufferAccommodate(t){const e=t*this.#Kt;return this.#Ht+e<=this.#Yt.byteLength}canElementsBufferAccommodate(t){const e=2*t;return this.#Qt+e<=this.#Xt.byteLength}writeToAttributeBuffer(t,e,n){this.#Yt.setFloat32(this.#Ht,Dt(t),!0),this.#Ht+=Cn.float32,this.#Yt.setFloat32(this.#Ht,Et(t),!0),this.#Ht+=Cn.float32,this.#Yt.setFloat32(this.#Ht,It(t),!0),this.#Ht+=Cn.float32,this.#Yt.setFloat32(this.#Ht,Dt(e),!0),this.#Ht+=Cn.float32,this.#Yt.setFloat32(this.#Ht,Et(e),!0),this.#Ht+=Cn.float32,this.#Yt.setFloat32(this.#Ht,It(e),!0),this.#Ht+=Cn.float32,this.#Yt.setUint32(this.#Ht,n.uint32_rgba,!1),this.#Ht+=Cn.uint32}writeToElementsBuffer(t,e){for(const t of e)this.#Xt.setUint16(this.#Qt,this.#ee+t,!0),this.#Qt+=Cn.uint16;this.#ee+=t,this.#ne+=e.length}setLightDirection(t){this.#se.uniforms.lightDirection.set(this.gl,t)}setProjectionMatrix(t){this.#se.uniforms.projectionMatrix.set(this.gl,t)}flush(){0!=this.#ee&&(this.gl.bindVertexArray(this.#Zt),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.#Jt),this.gl.bufferData(this.gl.ARRAY_BUFFER,this.#Yt,this.gl.DYNAMIC_DRAW,0,this.#Ht),this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,this.#te),this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER,this.#Xt,this.gl.DYNAMIC_DRAW,0,this.#Qt),this.gl.drawElements(this.gl.TRIANGLES,this.#ne,this.gl.UNSIGNED_SHORT,0),this.gl.bindVertexArray(null),this.#ne=0,this.#ee=0,this.#Ht=0,this.#Qt=0)}clearColorBufferBit(){this.gl.clear(this.gl.COLOR_BUFFER_BIT)}}const Cn={int8:1,uint8:1,int16:2,uint16:2,int32:4,uint32:4,float32:4};class Dn extends R{position=this.Input((()=>Ct(0,0,0)));anchor=this.Input((()=>Ct(0,0,0)));transform=this.Input((()=>Zt.Unit));dimensions=this.Input((()=>Ct(1,1,1)));color=this.Input((()=>O.Black));#oe;#V=this.Inject(Qt);constructor(t){super(t);const e=Ct(-.5,-.5,-.5),n=Ct(-.5,-.5,.5),r=Ct(-.5,.5,-.5),i=Ct(-.5,.5,.5),s=Ct(.5,-.5,-.5),o=Ct(.5,-.5,.5),a=Ct(.5,.5,-.5),c=Ct(.5,.5,.5),u=[n,o,c,i,s,e,r,a,e,n,i,r,o,s,a,c,i,c,a,r,o,n,e,s],l=[xt,xt,xt,xt,kt,kt,kt,kt,bt,bt,bt,bt,yt,yt,yt,yt,Tt,Tt,Tt,Tt,vt,vt,vt,vt];this.#oe=new Zt,this.traits.set(this.#V.geometry,u),this.traits.set(this.#V.vertexNormals,l),this.traits.set(this.#V.localTransform,this.#oe),this.traits.set(this.#V.geometryElements,Array.from(function*(t,e,n){for(let r=0;r<n;r++){const n=e*r;for(const e of t)yield n+e}}([0,1,2,0,2,3],4,6))),this.traits.set(this.#V.tintColor,O.LightGray)}onUpdate(){(this.position.didChange||this.transform.didChange||this.anchor.didChange||this.dimensions.didChange)&&this.#ae(),this.color.didChange&&this.traits.set(this.#V.tintColor,this.color.value)}onDestroy(){}#ae(){this.#oe.assign(this.transform.value),this.#oe.scaleWithin(this.dimensions.value[0]/2,function(t){return t[1]}(this.dimensions.value)/2,function(t){return t[2]}(this.dimensions.value)/2),this.#oe.translateWithin(-Dt(this.anchor.value),-Et(this.anchor.value),-It(this.anchor.value)),this.#oe.translate(Dt(this.position.value),Et(this.position.value),It(this.position.value))}}const En=new s("@morkite/webgl-components/3d/GROUP_TRAIT_TOKENS");class In extends R{position=this.Input((()=>Ct()));transform=this.Input((()=>Zt.Unit));children=this.Input();#oe;#V=this.Inject(En);constructor(t){super(t),this.#oe=new Zt,this.traits.set(this.#V.localTransform,this.#oe)}onUpdate(){if((this.position.didChange||this.transform.didChange)&&this.#ae(),this.children.didChange){this.childrenManager.count>0&&this.childrenManager.destroyAt(0);this.childrenManager.createAt(0,this.children.value).update()}}onDestroy(){}#ae(){this.#oe.assign(this.transform.value),this.#oe.translate(Dt(this.position.value),Et(this.position.value),It(this.position.value))}}const Sn=new s("@morkite/webgl-components/3d/PROJECTION_TRAIT_TOKENS"),An=new s;class Nn extends R{transform=this.Input((()=>Zt.Unit));color=this.Input((()=>O.Green));#V=this.Inject(An);constructor(t){super(t);const e=(1+Math.sqrt(5))/2,n=Ct(0,-e,-1),r=Ct(0,-e,1),i=Ct(0,+e,1),s=Ct(0,+e,-1),o=Ct(-1,0,-e),a=Ct(-1,0,+e),c=Ct(1,0,+e),u=Ct(1,0,-e),l=Ct(-e,-1,0),h=Ct(-e,1,0),p=Ct(+e,1,0),d=Ct(+e,-1,0),f=[n,r,i,s,o,a,c,u,l,h,p,d];for(const t of f)Bt(t,t),Ft(t,.6,t);const m=[n,r,l,r,n,d,i,s,h,s,i,p,o,u,n,u,o,s,c,a,r,a,c,i,l,h,o,h,l,a,p,d,u,d,p,c,n,l,o,r,a,l,s,o,h,i,h,a,n,u,d,r,d,c,s,p,u,i,c,p],g=[];for(let t=0;t<m.length/3;t++){const e=3*t,n=Fn(Ct(),m[e],m[e+1],m[e+2]);g.push(n,n,n)}this.traits.set(this.#V.geometry,m),this.traits.set(this.#V.vertexNormals,g),this.traits.set(this.#V.geometryElements,Array.from(function*(t,e,n){for(let r=0;r<n;r++){const n=e*r;for(const e of t)yield n+e}}([0,1,2],3,20))),this.traits.set(this.#V.localTransform,this.transform.value),this.traits.set(this.#V.tintColor,this.color.value)}onUpdate(){this.transform.didChange&&this.traits.set(this.#V.localTransform,this.transform.value),this.color.didChange&&this.traits.set(this.#V.tintColor,this.color.value),this.transform.didChange&&this.traits.set(this.#V.localTransform,this.transform.value)}onDestroy(){}}function Fn(t,e,n,r){return function(t,e,n){const[r,i,s]=e,[o,a,c]=n;St(t,i*c-s*a,s*o-r*c,r*a-i*o)}(t,Nt(Ct(),n,e),Nt(Ct(),r,n)),Bt(t,t)}function Bn(t=0,e=0,n=0){return[t,e,n]}function Vn(t){return Bn(t[0],t[1],t[2])}function Mn(t,e,n,r){return t[0]=e,t[1]=n,t[2]=r,t}function Rn(t,e){return t[0]==e[0]&&t[1]==e[1]&&t[2]==e[2]}function Pn(t){return 0==t[0]&&0==t[1]&&0==t[2]}function On(t,e,n){return Mn(t,e[0]+n[0],e[1]+n[1],e[2]+n[2])}class Ln extends rt{worldTile=this.Input();#ce=this.worldTile.flatMap((t=>t.position));#ue=this.#ce.map((t=>{return((e=t)[0]+e[1]+e[2])%2?O.DarkGray:O.Gray;var e}));template=ht(Dn).bind("color",this.#ue)}class Un extends rt{template=ht(In).setChildren([ht(Dn).bind("color",O.Red),ht(Nn).bind("transform",Zt.Unit.clone().translate(0,0,1)).bind("color",O.Red)])}class _n extends rt{template=ht(Dn).bind("color",O.Cyan)}class $n extends rt{worldTile=this.Input();#le=this.Inject(gt);#he=this.worldTile.flatMap((t=>t.position)).map((t=>Ft(Ct(),40,t)));worldTileType=this.worldTile.map((t=>t.data.get(Yt)));#pe=this.worldTile.flatMap((t=>t.position)).map((([t,e,n])=>(new Zt).translate(t,e,n).scale(30,30,30)));template=ht(In).bind("transform",this.#pe).setChildren([ht(dt).bind("condition",this.worldTileType.map((t=>t===Ht.Player))).setChildren([ht(Un)]),ht(dt).bind("condition",this.worldTileType.map((t=>t===Ht.Terrain))).setChildren([ht(Ln).bind("worldTile",this.worldTile)]),ht(dt).bind("condition",this.worldTileType.map((t=>t===Ht.Box))).setChildren([ht(_n)])])}function jn(t,e,n){return Bn(t,e,n)}const Wn=jn(1,0,0),zn=jn(-1,0,0),Gn=jn(0,1,0),qn=jn(0,-1,0);class Kn{world;position;orientation;data;constructor(t,e){this.world=t,this.position=P.Create(Vn(e)),this.orientation=P.Create(Gn),this.data=new d}changePosition(t){return this.world.changePosition(this,t),this}nudge(t,e=1){const n=Mn(Bn(),(i=e)*(r=t)[0],i*r[1],i*r[2]);var r,i;const s=On(Bn(),n,this.position.value);return this.changePosition(s)}changeOrientation(t){return this.world.changeOrientation(this,t),this}}class Yn{#de=new Set;constructor(){}*tiles(){yield*this.#de}*tilesAt(t){for(const e of this.#de)Rn(e.position.value,t)&&(yield e)}create(t){const e=new Kn(this,Vn(t));return this.#de.add(e),e}delete(t){return this.#de.delete(t),this}deleteAllFrom(t){for(const e of this.#de)Rn(e.position.value,t)&&this.delete(e);return this}changePosition(t,e){return t.position.set(Vn(e)),this}changeOrientation(t,e){return t.orientation.set(e),this}}function*Hn(t,e,n){for(let r=t[0]-(e.left??0);r<=t[0]+(e.right??0);r++)yield Bn(r,t[0]-(e.back??0),n),yield Bn(r,t[0]+(e.front??0),n);for(let r=t[0]-(e.back??0)+1;r<=t[0]+(e.front??0)-1;r++)yield Bn(t[0]-(e.left??0),r,n),yield Bn(t[0]+(e.right??0),r,n)}class Xn{static Instance=new this;applyForce(t){return{kind:"accepted"}}}class Qn{static Instance=new this;applyForce(t){return{kind:"rejected"}}}class Zn{static Instance1=new this(1);magnitudeThreshold;constructor(t){this.magnitudeThreshold=t}applyForce({magnitude:t,direction:e}){if(t<this.magnitudeThreshold)return{kind:"rejected"};return{kind:"delegated",delegated:{direction:e,magnitude:t-this.magnitudeThreshold}}}}const Jn=new p("FORCE_APPLIER");class tr{static Instance=new this;applyLaser(t){return Vn(t)}}class er{static Instance=new this;applyLaser(t){return Bn()}}const nr=new p("LASER_APPLIER"),rr=new d,ir=new p("FAN_STATE_IS_ACTIVE");class sr{playerTile;lebs=new Set;lasers=new Set;world;constructor(){this.world=new Yn;const t=function*(t,e){for(let n=t[0]-(e.left??0);n<=t[0]+(e.right??0);n++)for(let r=t[0]-(e.back??0);r<=t[1]+(e.front??0);r++)for(let i=t[0]-(e.down??0);i<=t[1]+(e.up??0);i++)yield Bn(n,r,i)}(Bn(),{front:6,back:6,left:6,right:6});for(const e of t){this.world.create(e).data.set(Yt,Ht.Terrain).set(Jn,Qn.Instance).set(nr,er.Instance)}for(const t of[1,2]){const e=Hn(Bn(),{front:6,back:6,left:6,right:6},t);for(const t of e){this.world.create(t).data.set(Yt,Ht.Terrain).set(Jn,Qn.Instance).set(nr,er.Instance)}}this.playerTile=this.world.create(Bn(0,0,1)),this.playerTile.data.set(Yt,Ht.Player).set(Jn,Qn.Instance).set(nr,er.Instance);const e=[Bn(2,-2,1),Bn(-1,-3,1)];for(const t of e){this.world.create(t).data.set(Yt,Ht.Box).set(Jn,Zn.Instance1).set(nr,er.Instance)}const n=[Bn(-3,2,1)];for(const t of n){const e=this.world.create(t);e.data.set(Yt,Ht.LaserEmittingBox).set(Jn,Zn.Instance1).set(nr,er.Instance),this.lebs.add(e)}const r=[Bn(-3,-3,1)];for(const t of r){this.world.create(t).data.set(Yt,Ht.Fan).set(Jn,Xn.Instance).set(nr,tr.Instance).set(ir,P.Create(!0)).set(Kt,-1)}}movePlayer(t){const e=new Map;this.applyForce(this.playerTile,{direction:t,magnitude:1},e);for(const[t,n]of e)t.changePosition(n)}applyForce(t,e,n){const r=On(Bn(),t.position.value,e.direction),i=[...this.world.tilesAt(r)];console.assert(i.length<=1);const s=0==i.length?null:i[0];if(null==s)return void n.set(t,r);const o=(s.data.get(Jn)??Xn.Instance).applyForce(e);switch(o.kind){case"rejected":return void n.clear();case"accepted":return void n.set(t,r);case"delegated":return n.set(t,r),this.applyForce(s,o.delegated,n)}}updateLasers(){for(const t of this.lasers)this.world.delete(t);this.lasers.clear();for(const n of this.lebs){const r=Bn(1,0,0),i=Vn(n.position.value);On(i,i,r);let s=100;for(;s-- >0;){const n=[...this.world.tilesAt(i)];console.assert(n.length<=1);const s=(0==n.length?rr:n[0].data).get(nr)??tr.Instance;if(t=r,e=s.applyLaser(r),Mn(t,e[0],e[1],e[2]),Pn(r))break;const o=this.world.create(i);o.data.set(Yt,Ht.Laser),this.lasers.add(o),On(i,i,r)}}var t,e}}class or{#fe=new Map;add(t,e){const n=this,r={token:t,trigger(t){e(t)},cancel(){n.#me(t,r)}};let i=this.#fe.get(t);return null==i&&(i=new Set,this.#fe.set(t,i)),i.add(r),r}triggerSubscriptions(t,e){const n=this.#fe.get(t);if(null!=n)for(const t of n)t.trigger(e)}#me(t,e){const n=this.#fe.get(t);null!=n&&(n.delete(e),0==n.size&&this.#fe.delete(t))}}class ar{#ge=new or;broadcast(t,e){this.#ge.triggerSubscriptions(t,e)}subscribe(t,e){return this.#ge.add(t,e)}}const cr=["KeyW","KeyA","KeyS","KeyD","KeyQ","KeyE","KeyF","KeyZ","KeyX","KeyC","Escape","AltLeft","ControlLeft"],ur=new p("@morkite/input-methods/keyboard/KEY_DOWN");class lr{#we;constructor(t){this.#we=t??new ar,document.addEventListener("keydown",(t=>{cr.includes(t.code)&&this.#we.broadcast(ur,t.code)}))}onKeyDown(t,e){return this.#we.subscribe(ur,(n=>{n===t&&e(n)}))}}var hr,pr,dr;!function(t){t[t.Linear=9729]="Linear",t[t.Nearest=9728]="Nearest"}(hr||(hr={})),function(t){t[t.Linear=9729]="Linear",t[t.Nearest=9728]="Nearest",t[t.NearestMipmapNearest=9984]="NearestMipmapNearest",t[t.LinearMipmapNearest=9985]="LinearMipmapNearest",t[t.NearestMipmapLinear=9986]="NearestMipmapLinear",t[t.LinearMipmapLinear=9987]="LinearMipmapLinear"}(pr||(pr={})),function(t){t[t.Repeat=10497]="Repeat",t[t.ClampToEdge=33071]="ClampToEdge",t[t.MirroredRepeat=33648]="MirroredRepeat"}(dr||(dr={}));class fr{static Default=new fr;magnificationFilter;minificationFilter;textureWrapping;constructor(t){this.magnificationFilter=t?.magnificationFilter??hr.Linear,this.minificationFilter=t?.minificationFilter??pr.NearestMipmapLinear,this.textureWrapping=null==t?.textureWrapping?{s:dr.Repeat,t:dr.Repeat}:"number"==typeof t.textureWrapping?{s:t.textureWrapping,t:t.textureWrapping}:{s:t.textureWrapping.s,t:t.textureWrapping.t}}}class mr{#ye=[];add(t){"full"==t.type&&this.clear(),this.#ye.push(t)}*[Symbol.iterator](){yield*this.#ye}clear(){this.#ye.splice(0,this.#ye.length)}}class gr{name;parameters;static TransparentPixel=new gr("transparent pixel",1,1);static WhitePixel=new gr("white pixel",1,1);static{this.TransparentPixel.queueFullUpload(new Uint8ClampedArray([0,0,0,0])),this.WhitePixel.queueFullUpload(new Uint8ClampedArray([255,255,255,255]))}dimensions;#be=1;get version(){return this.#be}constructor(t,e,n,r=fr.Default){this.name=t,this.parameters=r,this.dimensions=wt(e,n)}#ye=new mr;queueFullUpload(t){const e={type:"full",data:t};this.#ye.add(e),this.bumpVersion()}queuePartialUpload(t,e){const n={type:"partial",region:t,data:e};this.#ye.add(n),this.bumpVersion()}flush(){const t=Array.from(this.#ye);return this.#ye.clear(),t}bumpVersion(){this.#be++}}class wr{texture;static TransparentPixel=new wr(gr.TransparentPixel);rectangle;normalizedRectangle;constructor(t,e){this.texture=t;const n=Vt(this.texture.dimensions),r=Mt(this.texture.dimensions);this.rectangle=e??Ut(0,0,n,r),this.normalizedRectangle=function(t,e,n){const r=Rt(e)/Vt(n),i=Pt(e)/Mt(n),s=Ot(e)/Vt(n),o=Lt(e)/Mt(n);return function(t,e,n,r,i){return t[0]=e,t[1]=n,t[2]=r,t[3]=i,t}(t,r,i,s,o)}(Ut(),this.rectangle,this.texture.dimensions)}}class yr{texture;glTexture;unit;mostRecentlyUploadedVersion;constructor(t,e,n,r=-1){this.texture=t,this.glTexture=e,this.unit=n,this.mostRecentlyUploadedVersion=r}}class br{gl;textures=new Map;currentlyActiveUnit=0;constructor(t){this.gl=t}create(t){if(this._hasTexture(t))throw new Error("already created");const e=this.gl.createTexture();if(null==e)throw new Error("Expected glTexture to be non-null.");const n=new yr(t,e,null);this.textures.set(t,n)}bindTo(t,e){const n=this._getDetailsByTexture(t);if(null==n)throw new Error("Expected details to be non-null.");if(n.unit==e)return;const r=this._getDetailsByUnit(e);null!=r&&(r.unit=null),this._updateCurrentlyActiveUnit(e),this.gl.bindTexture(this.gl.TEXTURE_2D,n.glTexture),n.unit=e}upload(t,e){let n=this._getDetailsByTexture(e);if(null==n&&(this.create(e),n=this._getDetailsByTexture(e),null==n))throw new Error("errrm");if(this.bindTo(e,t),e.version==n.mostRecentlyUploadedVersion)return;this._updateCurrentlyActiveUnit(t),this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,e.parameters.magnificationFilter),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,e.parameters.minificationFilter),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,e.parameters.textureWrapping.s),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,e.parameters.textureWrapping.t);const r=e.flush();if(0==r.length)throw new Error(`Tried to use a texture with no data in it: ${e.name}.`);-1==n.mostRecentlyUploadedVersion&&"partial"==r[0].type&&this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,Vt(e.dimensions),Mt(e.dimensions),0,this.gl.RGBA,this.gl.UNSIGNED_BYTE,null);for(const t of r)switch(t.type){case"partial":this.gl.texSubImage2D(this.gl.TEXTURE_2D,0,Rt(t.region),Pt(t.region),Ot(t.region),Lt(t.region),this.gl.RGBA,this.gl.UNSIGNED_BYTE,t.data);break;case"full":this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,Vt(e.dimensions),Mt(e.dimensions),0,this.gl.RGBA,this.gl.UNSIGNED_BYTE,t.data)}n.mostRecentlyUploadedVersion=e.version}delete(t){const e=this._getDetailsByTexture(t);if(null==e)throw new Error("Expected details to be non-null.");this.gl.deleteTexture(e.glTexture),this.textures.delete(t)}_updateCurrentlyActiveUnit(t){this.currentlyActiveUnit!=t&&(this.gl.activeTexture(this.gl.TEXTURE0+t),this.currentlyActiveUnit=t)}_hasTexture(t){return this.textures.has(t)}_getDetailsByTexture(t){return this.textures.get(t)??null}_getDetailsByUnit(t){for(const e of this.textures.values())if(e.unit==t)return e;return null}}class Tr{unit;constructor(t){this.unit=t}texture=null;locked=!1}class vr{count;slots;constructor(t){this.count=t;const e=new Array(this.count);for(let n=0;n<t;n++)e[n]=new Tr(n);this.slots=e}getFirstFreeSlot(){for(const t of this.slots)if(null==t.texture)return t;return null}getByTexture(t){for(const e of this.slots)if(e.texture==t)return e;return null}getBySlotId(t){if(!Number.isInteger(t)||t<0||t>=this.count)throw new Error(`Not a valid ID: ${t}.`);return this.slots[t]}unlockAll(){for(const t of this.slots)t.locked=!1}getTextureSlots(){const t=new Map;for(const{unit:e,texture:n}of this.slots)null!=n&&t.set(n,e);return t}}class xr{capacity;evictionStrategy;slots;constructor(t,e){this.capacity=t,this.evictionStrategy=e,this.slots=new vr(t)}decideOnUnit(t){let e=this.slots.getByTexture(t);if(null==e){const t=this.slots.getFirstFreeSlot();if(null!=t)e=t;else{let t=!1;const n=this.evictionStrategy.judge();for(const r of n){const n=this.slots.getByTexture(r);if(null==n)throw new Error("Oops!");if(!n.locked){t=!0,e=n;break}}if(!t)return null}}return e.unit}lockInto(t,e){const n=this.slots.getBySlotId(t);null!=n.texture&&n.texture!=e&&this.evictionStrategy.forget(n.texture),n.texture=e,n.locked=!0,this.evictionStrategy.markUsage(e)}unlockAll(){this.slots.unlockAll()}}class kr{}class Cr extends kr{usageOrder=[];markUsage(t){const e=this.usageOrder.indexOf(t);e>-1&&this.usageOrder.splice(e,1),this.usageOrder.push(t)}forget(t){const e=this.usageOrder.indexOf(t);e>-1&&this.usageOrder.splice(e,1)}*judge(){yield*this.usageOrder}}class Dr{glContextTexturesManager;activeTexturesManager;#V;constructor(t){this.#V=t;const e=new Cr;this.activeTexturesManager=new xr(8,e)}onProcessorCreated(t){this.glContextTexturesManager=new br(t.gl)}onFrameStart(){}process(t){const e=t.get(this.#V.requiredTexture);if(null==e)return new j;const n=this.activeTexturesManager.decideOnUnit(e);return null==n?new Ir(this):new Er(this,t,e,n,this.#V)}createBreakCommand(){return new Ir(this)}onFrameFinish(){}}class Er extends ${processor;nugget;texture;unit;traitTokens;constructor(t,e,n,r,i){super(!1),this.processor=t,this.nugget=e,this.texture=n,this.unit=r,this.traitTokens=i}execute(){this.nugget.set(this.traitTokens.textureUnit,this.unit),this.processor.activeTexturesManager.lockInto(this.unit,this.texture),this.processor.glContextTexturesManager.upload(this.unit,this.texture)}}class Ir extends ${processor;constructor(t){super(!0),this.processor=t}execute(){this.processor.activeTexturesManager.unlockAll()}}const Sr=new s("TRAIT_TOKENS");function Ar(t,e,n,r,i){return(i-t)*(r-n)/(e-t)+n}class Nr{#Te;get tileDimensionsPx(){return this.#Te.tileDimensionsPx}constructor(t){this.#Te=t}getProjection(t,e){const[n,r,i]=t,[s,o,a]=e,c=this.#Te.tileDimensionsPx;return wt(c/2*(n*s-r*o),-c/4*(n*s+r*o)+c/2*i*a)}}Error.stackTraceLimit=1/0;new class{#ve;#xe;#ke=null;#Ce;#De;#Ee;#D;constructor(t){this.#xe=t.sceneRoot;const n=document.createElement("canvas");n.width=1280,n.height=720;t.htmlRoot.append(n);const r=n.getContext("webgl2");if(null==r)throw new Error("Expected “gl” to be non-nullish.");const i=new gn(r),s=new kn(r,i),o={debuggingName:new p("traitTokens/debuggingName"),childrenAccessor:new p("traitTokens/childrenAccessor"),undo:new p("traitTokens/undo"),localTransform:new p("traitTokens/localTransform"),worldTransform:new p("traitTokens/worldTransform"),geometry:new p("traitTokens/geometry"),geometryElements:new p("traitTokens/geometryElements"),requiredTexture:new p("traitTokens/requiredTexture"),textureUnit:new p("traitTokens/textureUnit"),texturePosition:new p("traitTokens/texturePosition"),tintColor:new p("traitTokens/tintColor"),projection:new p("traitTokens/projection"),vertexNormals:new p("traitTokens/normals"),directionalLight:new p("traitTokens/directionalLight")},a={worldTransform:new p("frameStorageTokens/worldTransform")},l=new K([new Y({debuggingName:o.debuggingName}),new ne,new se({directionalLight:o.directionalLight}),new ie({projection:o.projection}),new nt({debuggingName:o.debuggingName,undo:o.undo,childrenAccessor:o.childrenAccessor},{undoEligibilityTraits:[o.localTransform,o.geometry]}),new re({undo:o.undo,localTransform:o.localTransform,worldTransform:o.worldTransform},{worldTransform:a.worldTransform}),new Dr({requiredTexture:o.requiredTexture,textureUnit:o.textureUnit}),new Jt({geometry:o.geometry,geometryElements:o.geometryElements,tintColor:o.tintColor,vertexNormals:o.vertexNormals},{worldTransform:a.worldTransform}),new X]),h=new q(s,l),d=new Z,f=new et(d),m=new S,g=new V([new B,new st]),w=new ar,y=new lr(w),b=new c;if(b.provide(e(Q,d)),b.provide(e(J,f)),b.provide(e(S,m)),b.provide(e(N,g)),b.provide(e(ar,w)),b.provide(e(lr,y)),b.provide(e(Sr,o)),b.provide(e(u,{debuggingName:o.debuggingName,childrenAccessor:o.childrenAccessor})),b.provide(e(En,{localTransform:o.localTransform})),b.provide(e(Sn,{projection:o.projection})),b.provide(e(Xt,{tintColor:o.tintColor,geometry:o.geometry,geometryElements:o.geometryElements})),b.provide(e(Qt,{geometry:o.geometry,geometryElements:o.geometryElements,tintColor:o.tintColor,localTransform:o.localTransform,vertexNormals:o.vertexNormals})),b.provide(e(An,o)),null!=t.providers)for(const e of t.providers)b.provide(e);this.#ve=b,this.#Ce=h,this.#De=m,this.#Ee=f,this.#D=g}start(){const t=this.#D.instantiateOrThrow(this.#xe,this.#ve);this.#ke=t,t.activate({depth:0}),this.#De.markAsDirty(t);const e=this.#Ee.subscribe((()=>{Promise.resolve().then((()=>{let e=1e4;for(const t of this.#De.iterate())if(t.update(),e--<0)throw new Error(`(Don't) hang in there, man. The culprit seems to be ${t.constructor.name}.`);this.#Ce.renderFrame(t.traits)})).catch((t=>{console.error("Rendering a frame crashed. Not rendering any more to avoid cluttering the output."),console.error(t),e.unsubscribe()}))}))}destroy(){throw this.#ke?.destroy(),new Error("Not implemented.")}}({htmlRoot:document.body,sceneRoot:class extends rt{#Ie=new sr;#Se=P.Create([]);#Ae=function(){const t=P.Create(wt(0,0));return document.addEventListener("mousemove",(function(e){t.set(wt(e.clientX,e.clientY))})),t}(this.injector);#pe=this.#Ae.map((([t,e])=>{const n=Ar(0,window.innerWidth,0,2*Math.PI,t),r=Ar(0,window.innerHeight,-Math.PI/6,-(Math.PI/2-Math.PI/6),e);return(new Zt).scale(2,2,2).rotateAroundZ(n).rotateAroundX(r)}));#Ne(){const t=Array.from(this.#Ie.world.tiles());this.#Se.set(t)}constructor(t){super(t),this.traits.set(this.Inject(Sr).directionalLight,Ct(2,-5,-3));const e=this.injector.resolve(lr);e.onKeyDown("KeyQ",(()=>{})),e.onKeyDown("KeyE",(()=>{})),e.onKeyDown("KeyW",(()=>{this.#Ie.movePlayer(Gn),this.#Ie.updateLasers(),this.#Ne()})),e.onKeyDown("KeyS",(()=>{this.#Ie.movePlayer(qn),this.#Ie.updateLasers(),this.#Ne()})),e.onKeyDown("KeyA",(()=>{this.#Ie.movePlayer(zn),this.#Ie.updateLasers(),this.#Ne()})),e.onKeyDown("KeyD",(()=>{this.#Ie.movePlayer(Wn),this.#Ie.updateLasers(),this.#Ne()})),this.#Ie.updateLasers(),this.#Ne()}template=ht(In).bind("transform",this.#pe).setChildren([ht(mt).bind("items",this.#Se).bind("itemComponent",lt({item:ct(),index:ct()},(({item:t})=>ht($n).bind("worldTile",t))))])},providers:[function(e,n=e){return{[t]:!0,type:"class-provider",token:e,classConstructor:n}}(gt),e(Nr,new Nr({tileDimensionsPx:32}))]}).start();
//# sourceMappingURL=main.js.map
